!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AC_KSEQ_H	kseq.h	29;"	d
AlnProcessor	ProcessReads.cpp	/^AlnProcessor::AlnProcessor(AlnProcessor && o) :$/;"	f	class:AlnProcessor
AlnProcessor	ProcessReads.cpp	/^AlnProcessor::AlnProcessor(const KmerIndex& index, const ProgramOptions& opt, MasterProcessor& mp, const EMAlgorithm& em, const Transcriptome &model, bool useEM, int _id) :$/;"	f	class:AlnProcessor
AlnProcessor	ProcessReads.h	/^class AlnProcessor {$/;"	c
BFG_KMER_HPP	Kmer.hpp	2;"	d
BFG_KMER_ITERATOR_HPP	KmerIterator.hpp	2;"	d
BUSData	BUSData.h	/^  BUSData() : barcode(0), UMI(0), ec(-1), count(0), flags(0), pad(0) {}$/;"	f	struct:BUSData
BUSData	BUSData.h	/^struct BUSData {$/;"	s
BUSFORMAT_VERSION	BUSData.h	/^const uint32_t BUSFORMAT_VERSION = 1;$/;"	v
BUSHeader	BUSData.h	/^  BUSHeader() : version(0), bclen(0), umilen(0) {}$/;"	f	struct:BUSHeader
BUSHeader	BUSData.h	/^struct BUSHeader {$/;"	s
BUSOptionSubstr	common.h	/^  BUSOptionSubstr() : fileno(-1), start(0), stop(0) {}$/;"	f	struct:BUSOptionSubstr
BUSOptionSubstr	common.h	/^  BUSOptionSubstr(int f, int a, int b) : fileno(f), start(a), stop(b) {}$/;"	f	struct:BUSOptionSubstr
BUSOptionSubstr	common.h	/^struct BUSOptionSubstr {$/;"	s
BUSOptions	common.h	/^struct BUSOptions {$/;"	s
BUSProcessor	ProcessReads.cpp	/^BUSProcessor::BUSProcessor(BUSProcessor && o) :$/;"	f	class:BUSProcessor
BUSProcessor	ProcessReads.cpp	/^BUSProcessor::BUSProcessor(const KmerIndex& index, const ProgramOptions& opt, const MinCollector& tc, MasterProcessor& mp, int _id, int _local_id) :$/;"	f	class:BUSProcessor
BUSProcessor	ProcessReads.h	/^class BUSProcessor {$/;"	c
BUSTranscript	BUSData.h	/^  BUSTranscript() : transcriptLength(0) {}  $/;"	f	struct:BUSTranscript
BUSTranscript	BUSData.h	/^struct BUSTranscript {$/;"	s
BamSequenceReader	ProcessReads.h	/^  BamSequenceReader() : SequenceReader() {};$/;"	f	class:BamSequenceReader
BamSequenceReader	ProcessReads.h	/^  BamSequenceReader(const ProgramOptions& opt) :$/;"	f	class:BamSequenceReader
BamSequenceReader	ProcessReads.h	/^class BamSequenceReader : public SequenceReader {$/;"	c
BiasWeightStruct	MinCollector.h	/^  BiasWeightStruct(int trid, char o, int pos, int referrer, double weight)$/;"	f	struct:BiasWeightStruct
BiasWeightStruct	MinCollector.h	/^struct BiasWeightStruct {$/;"	s
Bootstrap	Bootstrap.h	/^  Bootstrap(const std::vector<int>& true_counts,$/;"	f	class:Bootstrap
Bootstrap	Bootstrap.h	/^class Bootstrap {$/;"	c
BootstrapThreadPool	Bootstrap.cpp	/^BootstrapThreadPool::BootstrapThreadPool($/;"	f	class:BootstrapThreadPool
BootstrapThreadPool	Bootstrap.h	/^class BootstrapThreadPool {$/;"	c
BootstrapWorker	Bootstrap.h	/^    BootstrapWorker(BootstrapThreadPool& pool, size_t thread_id) :$/;"	f	class:BootstrapWorker
BootstrapWorker	Bootstrap.h	/^class BootstrapWorker {$/;"	c
BootstrapWriter	Bootstrap.h	/^class BootstrapWriter {$/;"	c
BuildDeBruijnGraph	KmerIndex.cpp	/^void KmerIndex::BuildDeBruijnGraph(const ProgramOptions& opt, const std::vector<std::string>& seqs) {$/;"	f	class:KmerIndex
BuildEquivalenceClasses	KmerIndex.cpp	/^void KmerIndex::BuildEquivalenceClasses(const ProgramOptions& opt, const std::vector<std::string>& seqs) {$/;"	f	class:KmerIndex
BuildTranscripts	KmerIndex.cpp	/^void KmerIndex::BuildTranscripts(const ProgramOptions& opt) {$/;"	f	class:KmerIndex
CheckOptionsBus	main.cpp	/^bool CheckOptionsBus(ProgramOptions& opt) {$/;"	f
CheckOptionsEM	main.cpp	/^bool CheckOptionsEM(ProgramOptions& opt, bool emonly = false) {$/;"	f
CheckOptionsH5Dump	main.cpp	/^bool CheckOptionsH5Dump(ProgramOptions& opt) {$/;"	f
CheckOptionsIndex	main.cpp	/^bool CheckOptionsIndex(ProgramOptions& opt) {$/;"	f
CheckOptionsInspect	main.cpp	/^bool CheckOptionsInspect(ProgramOptions& opt) {$/;"	f
CheckOptionsMerge	main.cpp	/^bool CheckOptionsMerge(ProgramOptions& opt) {$/;"	f
CheckOptionsPseudo	main.cpp	/^bool CheckOptionsPseudo(ProgramOptions& opt) {$/;"	f
Chromosome	GeneModel.h	/^struct Chromosome {$/;"	s
ComparePairsBySecond	MinCollector.cpp	/^struct ComparePairsBySecond {$/;"	s	file:
Contig	KmerIndex.h	/^struct Contig {$/;"	s
ContigToTranscript	KmerIndex.h	/^struct ContigToTranscript {$/;"	s
DBGraph	KmerIndex.h	/^struct DBGraph {$/;"	s
DataStructurePointerType	KmerHashTable.h	/^    typedef typename std::conditional<is_const_iterator, const KmerHashTable *, KmerHashTable *>::type DataStructurePointerType;$/;"	t	class:KmerHashTable::iterator_
Dna	KmerIndex.cpp	/^const char Dna(int i) {$/;"	f
ECStruct	Inspect.h	/^struct ECStruct {$/;"	s
EMAlgorithm	EMAlgorithm.h	/^  EMAlgorithm(const std::vector<int>& counts,$/;"	f	struct:EMAlgorithm
EMAlgorithm	EMAlgorithm.h	/^struct EMAlgorithm {$/;"	s
ERROR_STR	main.cpp	32;"	d	file:
ExonModel	GeneModel.h	/^struct ExonModel {$/;"	s
FR	common.h	/^  enum class StrandType {None, FR, RF};$/;"	m	class:ProgramOptions::StrandType
FastqSequenceReader	ProcessReads.cpp	/^FastqSequenceReader::FastqSequenceReader(FastqSequenceReader&& o) :$/;"	f	class:FastqSequenceReader
FastqSequenceReader	ProcessReads.h	/^  FastqSequenceReader() : SequenceReader(), $/;"	f	class:FastqSequenceReader
FastqSequenceReader	ProcessReads.h	/^  FastqSequenceReader(const ProgramOptions& opt) : SequenceReader(opt),$/;"	f	class:FastqSequenceReader
FastqSequenceReader	ProcessReads.h	/^class FastqSequenceReader : public SequenceReader {$/;"	c
FixSplitContigs	KmerIndex.cpp	/^void KmerIndex::FixSplitContigs(const ProgramOptions& opt, std::vector<std::vector<TRInfo>>& trinfos) {$/;"	f	class:KmerIndex
GENE_MODEL_HPP	GeneModel.h	2;"	d
GeneModel	GeneModel.h	/^struct GeneModel {$/;"	s
H5Converter	H5Writer.cpp	/^H5Converter::H5Converter(const std::string& h5_fname, const std::string& out_dir) :$/;"	f	class:H5Converter
H5Converter	H5Writer.h	/^class H5Converter {$/;"	c
H5Writer	H5Writer.h	/^    H5Writer() : primed_(false) {}$/;"	f	class:H5Writer
H5Writer	H5Writer.h	/^class H5Writer : public BootstrapWriter {$/;"	c
HASH_H	hash.hpp	2;"	d
INDEX_VERSION	KmerIndex.h	/^  const size_t INDEX_VERSION = 10; \/\/ increase this every time you change the fileformat$/;"	m	struct:KmerIndex
InspectIndex	Inspect.h	/^void InspectIndex(const KmerIndex& index, const ProgramOptions& opt) {$/;"	f
KALLISTO_BOOTSTRAP_H	Bootstrap.h	2;"	d
KALLISTO_BUSDATA_H	BUSData.h	2;"	d
KALLISTO_BUSTOOLS_H	BUSTools.h	2;"	d
KALLISTO_COMMON_H	common.h	2;"	d
KALLISTO_EMALGORITHM_H	EMAlgorithm.h	2;"	d
KALLISTO_H5WRITER_H	H5Writer.h	3;"	d
KALLISTO_H5_UTILS	h5utils.h	3;"	d
KALLISTO_INSPECTINDEX_H	Inspect.h	2;"	d
KALLISTO_KMERHASHTABLE_H	KmerHashTable.h	2;"	d
KALLISTO_KMERINDEX_H	KmerIndex.h	2;"	d
KALLISTO_MERGE_H	Merge.h	2;"	d
KALLISTO_MINCOLLECTOR_H	MinCollector.h	2;"	d
KALLISTO_MULTINOMIAL_H	Multinomial.hpp	2;"	d
KALLISTO_PLAINTEXT_WRITER_H	PlaintextWriter.h	2;"	d
KALLISTO_PROCESSREADS_H	ProcessReads.h	2;"	d
KALLISTO_PSEUDOBAM_H	PseudoBam.h	2;"	d
KALLISTO_VERSION	common.h	4;"	d
KALLISTO_WEIGHTS_H	weights.h	2;"	d
KSEQ_DECLARE	kseq.h	235;"	d
KSEQ_INIT	kseq.h	233;"	d
KSEQ_INIT2	kseq.h	227;"	d
KSEQ_INIT_READY	KmerIndex.cpp	10;"	d	file:
KSEQ_INIT_READY	ProcessReads.h	30;"	d
KSTREAM_INIT	kseq.h	148;"	d
KSTRING_T	kseq.h	82;"	d
KS_SEP_LINE	kseq.h	37;"	d
KS_SEP_MAX	kseq.h	38;"	d
KS_SEP_SPACE	kseq.h	35;"	d
KS_SEP_TAB	kseq.h	36;"	d
Kmer	Kmer.cpp	/^Kmer::Kmer() {$/;"	f	class:Kmer
Kmer	Kmer.cpp	/^Kmer::Kmer(const Kmer& o) {$/;"	f	class:Kmer
Kmer	Kmer.cpp	/^Kmer::Kmer(const char *s) {$/;"	f	class:Kmer
Kmer	Kmer.hpp	/^class Kmer {$/;"	c
KmerEntry	KmerIndex.h	/^  KmerEntry() : contig(-1), _pos(0xFFFFFFF), contig_length(0) {}$/;"	f	struct:KmerEntry
KmerEntry	KmerIndex.h	/^  KmerEntry(int id, int length, int pos, bool isFw) : contig(id), contig_length(length) {$/;"	f	struct:KmerEntry
KmerEntry	KmerIndex.h	/^struct KmerEntry {$/;"	s
KmerHash	Kmer.hpp	/^struct KmerHash {$/;"	s
KmerHashTable	KmerHashTable.h	/^  KmerHashTable(const Hash& h = Hash() ) : hasher(h), table(nullptr), size_(0), pop(0) {$/;"	f	struct:KmerHashTable
KmerHashTable	KmerHashTable.h	/^  KmerHashTable(size_t sz, const Hash& h = Hash() ) : hasher(h), table(nullptr), size_(0), pop(0) {$/;"	f	struct:KmerHashTable
KmerHashTable	KmerHashTable.h	/^struct KmerHashTable {$/;"	s
KmerIndex	KmerIndex.h	/^  KmerIndex(const ProgramOptions& opt) : k(opt.k), num_trans(0), skip(opt.skip), target_seqs_loaded(false) {$/;"	f	struct:KmerIndex
KmerIndex	KmerIndex.h	/^struct KmerIndex {$/;"	s
KmerIterator	KmerIterator.hpp	/^  KmerIterator() : s_(NULL), p_(), invalid_(true) {}$/;"	f	class:KmerIterator
KmerIterator	KmerIterator.hpp	/^  KmerIterator(const KmerIterator& o) : s_(o.s_), p_(o.p_), invalid_(o.invalid_) {}$/;"	f	class:KmerIterator
KmerIterator	KmerIterator.hpp	/^  KmerIterator(const char *s) : s_(s), p_(), invalid_(false) { find_next(-1,-1,false);}$/;"	f	class:KmerIterator
KmerIterator	KmerIterator.hpp	/^class KmerIterator : public std::iterator<std::input_iterator_tag, std::pair<Kmer, int>, int> {$/;"	c
ListSingleCellTechnologies	main.cpp	/^void ListSingleCellTechnologies() {$/;"	f
MAX_FRAG_LEN	MinCollector.h	/^const int MAX_FRAG_LEN = 1000;$/;"	v
MAX_K	Kmer.hpp	/^  static const unsigned int MAX_K = MAX_KMER_SIZE;$/;"	m	class:Kmer
MAX_KMER_SIZE	Kmer.hpp	5;"	d
MIN_ALPHA	weights.cpp	/^const double MIN_ALPHA = 1e-8;$/;"	v
MasterProcessor	ProcessReads.h	/^  MasterProcessor (KmerIndex &index, const ProgramOptions& opt, MinCollector &tc, const Transcriptome& model)$/;"	f	class:MasterProcessor
MasterProcessor	ProcessReads.h	/^class MasterProcessor {$/;"	c
MergeBatchDirectories	Merge.cpp	/^bool MergeBatchDirectories(const ProgramOptions &opt, int& num_targets, int64_t& num_processed, $/;"	f
MinCollector	MinCollector.h	/^  MinCollector(KmerIndex& ind, const ProgramOptions& opt)$/;"	f	struct:MinCollector
MinCollector	MinCollector.h	/^struct MinCollector {$/;"	s
Multinomial	Multinomial.hpp	/^        Multinomial(const std::vector<int>& counts, size_t seed = 42) :$/;"	f	class:Multinomial
Multinomial	Multinomial.hpp	/^class Multinomial {$/;"	c
MurmurHash3_x64_128	hash.cpp	/^void MurmurHash3_x64_128 ( const void *key, const int len, const uint32_t seed, void *out ) {$/;"	f
MurmurHash3_x64_32	hash.cpp	/^void MurmurHash3_x64_32 ( const void *key, int len, uint32_t seed, void *out ) {$/;"	f
MurmurHash3_x64_64	hash.cpp	/^void MurmurHash3_x64_64 ( const void *key, int len, uint32_t seed, void *out ) {$/;"	f
None	common.h	/^  enum class StrandType {None, FR, RF};$/;"	m	class:ProgramOptions::StrandType
ParseOptionsBus	main.cpp	/^void ParseOptionsBus(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsEM	main.cpp	/^void ParseOptionsEM(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsEMOnly	main.cpp	/^void ParseOptionsEMOnly(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsH5Dump	main.cpp	/^void ParseOptionsH5Dump(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsIndex	main.cpp	/^void ParseOptionsIndex(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsInspect	main.cpp	/^void ParseOptionsInspect(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsMerge	main.cpp	/^void ParseOptionsMerge(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseOptionsPseudo	main.cpp	/^void ParseOptionsPseudo(int argc, char **argv, ProgramOptions& opt) {$/;"	f
ParseTechnology	main.cpp	/^bool ParseTechnology(const std::string &techstr, BUSOptions& busopt, std::vector<std::string> &errorList) {$/;"	f
PrintCite	main.cpp	/^void PrintCite() {$/;"	f
PrintVersion	main.cpp	/^void PrintVersion() {$/;"	f
ProcessBUSReads	ProcessReads.cpp	/^int64_t ProcessBUSReads(MasterProcessor& MP, const  ProgramOptions& opt) {$/;"	f
ProcessBatchReads	ProcessReads.cpp	/^int64_t ProcessBatchReads(MasterProcessor& MP, const ProgramOptions& opt) {$/;"	f
ProcessReads	ProcessReads.cpp	/^int64_t ProcessReads(MasterProcessor& MP, const  ProgramOptions& opt) {$/;"	f
ProgramOptions	common.h	/^ProgramOptions() :$/;"	f	struct:ProgramOptions
ProgramOptions	common.h	/^struct ProgramOptions {$/;"	s
PseudoAlignmentBatch	PseudoBam.h	/^  PseudoAlignmentBatch() : batch_id(-1) {}$/;"	f	struct:PseudoAlignmentBatch
PseudoAlignmentBatch	PseudoBam.h	/^struct PseudoAlignmentBatch {$/;"	s
PseudoAlignmentInfo	PseudoBam.h	/^  PseudoAlignmentInfo() : id(-1), r1empty (true), r2empty(true), paired(true), k1pos(-1), k2pos(-1), ec_id(-1), barcode(0), UMI(0) {}$/;"	f	struct:PseudoAlignmentInfo
PseudoAlignmentInfo	PseudoBam.h	/^struct PseudoAlignmentInfo {$/;"	s
ReadProcessor	ProcessReads.cpp	/^ReadProcessor::ReadProcessor(ReadProcessor && o) :$/;"	f	class:ReadProcessor
ReadProcessor	ProcessReads.cpp	/^ReadProcessor::ReadProcessor(const KmerIndex& index, const ProgramOptions& opt, const MinCollector& tc, MasterProcessor& mp, int _id, int _local_id) :$/;"	f	class:ReadProcessor
ReadProcessor	ProcessReads.h	/^class ReadProcessor {$/;"	c
RefInfo	MinCollector.cpp	/^enum RefInfo { ref, alt, alt2, nonvariant };$/;"	g	file:
SR	ProcessReads.h	/^  SequenceReader *SR;$/;"	m	class:MasterProcessor
SequenceReader	ProcessReads.h	/^  SequenceReader() : state(false), readbatch_id(-1) {};$/;"	f	class:SequenceReader
SequenceReader	ProcessReads.h	/^  SequenceReader(const ProgramOptions& opt) :$/;"	f	class:SequenceReader
SequenceReader	ProcessReads.h	/^class SequenceReader {$/;"	c
SortedIntPairHasher	EMAlgorithm.h	/^struct SortedIntPairHasher {$/;"	s
SortedVectorHasher	KmerIndex.h	/^struct SortedVectorHasher {$/;"	s
SortedVectorPairHasher	KmerIndex.h	/^struct SortedVectorPairHasher {$/;"	s
StrandType	common.h	/^  enum class StrandType {None, FR, RF};$/;"	c	struct:ProgramOptions
SuperFastHash	hash.cpp	/^uint32_t SuperFastHash (const char *data, int len) {$/;"	f
TOLERANCE	EMAlgorithm.h	/^const double TOLERANCE = std::numeric_limits<double>::denorm_min();$/;"	v
TRInfo	KmerIndex.h	/^struct TRInfo {$/;"	s
TranscriptAlignment	GeneModel.h	/^  TranscriptAlignment() : chr(-1), chrpos(-1), strand(true) {}$/;"	f	struct:TranscriptAlignment
TranscriptAlignment	GeneModel.h	/^struct TranscriptAlignment {$/;"	s
TranscriptModel	GeneModel.h	/^struct TranscriptModel {$/;"	s
Transcriptome	GeneModel.h	/^struct Transcriptome {$/;"	s
UMI	BUSData.h	/^  uint64_t UMI;$/;"	m	struct:BUSData
UMI	PseudoBam.h	/^  uint64_t UMI;$/;"	m	struct:PseudoAlignmentInfo
ValuePointerType	KmerHashTable.h	/^    typedef typename std::conditional<is_const_iterator, const value_type *, value_type *>::type ValuePointerType;$/;"	t	class:KmerHashTable::iterator_
ValueReferenceType	KmerHashTable.h	/^    typedef typename std::conditional<is_const_iterator, const value_type&, value_type&>::type ValueReferenceType;$/;"	t	class:KmerHashTable::iterator_
VariantParameterEntry	KmerIndex.h	/^    VariantParameterEntry(int trid, int pos, char orientation, std::string ref, std::string alt) :$/;"	f	struct:VariantParameterEntry
VariantParameterEntry	KmerIndex.h	/^struct VariantParameterEntry {$/;"	s
__KSEQ_BASIC	kseq.h	156;"	d
__KSEQ_READ	kseq.h	177;"	d
__KSEQ_TYPE	kseq.h	220;"	d
__KS_BASIC	kseq.h	51;"	d
__KS_GETC	kseq.h	67;"	d
__KS_GETUNTIL	kseq.h	93;"	d
__KS_TYPE	kseq.h	40;"	d
__kstring_t	kseq.h	/^typedef struct __kstring_t {$/;"	s
_pos	KmerIndex.h	/^  uint32_t _pos; \/\/ 0-based forward distance to EC-junction$/;"	m	struct:KmerEntry
_rotl64	hash.cpp	/^uint64_t inline _rotl64(uint64_t value, int8_t amount) {$/;"	f
addGTFLine	GeneModel.cpp	/^int Transcriptome::addGTFLine(const std::string &line, const KmerIndex& index, bool guessChromosomes) {$/;"	f	class:Transcriptome
all_fl_means	EMAlgorithm.h	/^  const std::vector<double>& all_fl_means;$/;"	m	struct:EMAlgorithm
aln	PseudoBam.h	/^  std::vector<PseudoAlignmentInfo> aln;$/;"	m	struct:PseudoAlignmentBatch
alpha_	EMAlgorithm.h	/^  std::vector<double> alpha_;$/;"	m	struct:EMAlgorithm
alpha_before_zeroes_	EMAlgorithm.h	/^  std::vector<double> alpha_before_zeroes_;$/;"	m	struct:EMAlgorithm
alpha_buf_	H5Writer.h	/^    std::vector<double> alpha_buf_;$/;"	m	class:H5Converter
alt	KmerIndex.h	/^    std::string alt;$/;"	m	struct:VariantParameterEntry
alt	MinCollector.cpp	/^enum RefInfo { ref, alt, alt2, nonvariant };$/;"	e	enum:RefInfo	file:
alt2	MinCollector.cpp	/^enum RefInfo { ref, alt, alt2, nonvariant };$/;"	e	enum:RefInfo	file:
argv_to_string	main.cpp	/^std::string argv_to_string(int argc, char *argv[]) {$/;"	f
aseCounts	MinCollector.h	/^  std::unordered_map<int, int> aseCounts;$/;"	m	struct:MinCollector
aseCounts	ProcessReads.h	/^  std::unordered_map<int, int> aseCounts;$/;"	m	class:ReadProcessor
aseCounts_	EMAlgorithm.h	/^  const std::unordered_map<int, int>& aseCounts_;$/;"	m	struct:EMAlgorithm
ase_bias_weights_	EMAlgorithm.h	/^  std::vector<std::vector<double>> ase_bias_weights_;$/;"	m	struct:EMAlgorithm
aux_	H5Writer.h	/^    hid_t aux_;$/;"	m	class:H5Converter
aux_	H5Writer.h	/^    hid_t aux_;$/;"	m	class:H5Writer
backwardBase	Kmer.cpp	/^Kmer Kmer::backwardBase(const char b) const {$/;"	f	class:Kmer
bam	ProcessReads.h	/^  bool bam;$/;"	m	class:BUSProcessor
bam	common.h	/^  bool bam;$/;"	m	struct:ProgramOptions
bambuffer	ProcessReads.h	/^  char *bambuffer;$/;"	m	class:AlnProcessor
bambufsize	ProcessReads.h	/^  size_t bambufsize;$/;"	m	class:AlnProcessor
bamfp	ProcessReads.h	/^  htsFile *bamfp;$/;"	m	class:MasterProcessor
bamfps	ProcessReads.h	/^  htsFile **bamfps;$/;"	m	class:MasterProcessor
bamh	ProcessReads.h	/^  bam_hdr_t *bamh;$/;"	m	class:MasterProcessor
barcode	BUSData.h	/^  uint64_t barcode;$/;"	m	struct:BUSData
barcode	PseudoBam.h	/^  uint64_t barcode;$/;"	m	struct:PseudoAlignmentInfo
batchCounts	ProcessReads.h	/^  std::vector<std::vector<std::pair<int32_t, int32_t>>> batchCounts;$/;"	m	class:MasterProcessor
batchFlens	ProcessReads.h	/^  std::vector<std::vector<int>> batchFlens;$/;"	m	class:MasterProcessor
batchSR	ProcessReads.h	/^  FastqSequenceReader batchSR;$/;"	m	class:AlnProcessor
batchSR	ProcessReads.h	/^  FastqSequenceReader batchSR;$/;"	m	class:ReadProcessor
batchUmis	ProcessReads.h	/^  std::vector<std::vector<std::pair<int, std::string>>> batchUmis;$/;"	m	class:MasterProcessor
batch_file_name	common.h	/^  std::string batch_file_name;$/;"	m	struct:ProgramOptions
batch_files	common.h	/^  std::vector<std::vector<std::string>> batch_files;$/;"	m	struct:ProgramOptions
batch_id	PseudoBam.h	/^  int32_t batch_id;$/;"	m	struct:PseudoAlignmentBatch
batch_ids	common.h	/^  std::vector<std::string> batch_ids;$/;"	m	struct:ProgramOptions
batch_mode	common.h	/^  bool batch_mode;$/;"	m	struct:ProgramOptions
bc	ProcessReads.h	/^  char *bc;$/;"	m	class:BamSequenceReader
bc	common.h	/^  std::vector<BUSOptionSubstr> bc;$/;"	m	struct:BUSOptions
bc_len	ProcessReads.h	/^  int bc_len[33];$/;"	m	class:BUSProcessor
bc_weight_trids	KmerIndex.h	/^  std::unordered_set<int> bc_weight_trids;$/;"	m	struct:KmerIndex
bc_weights	KmerIndex.h	/^  std::unordered_map<int, double> bc_weights;$/;"	m	struct:KmerIndex
bclen	BUSData.h	/^  uint32_t bclen;$/;"	m	struct:BUSHeader
bedFile	common.h	/^  std::string bedFile;$/;"	m	struct:ProgramOptions
begin	KmerHashTable.h	/^  const_iterator begin() const {$/;"	f	struct:KmerHashTable
begin	KmerHashTable.h	/^  iterator begin() {$/;"	f	struct:KmerHashTable
bias	common.h	/^  bool bias;$/;"	m	struct:ProgramOptions
bias3	MinCollector.h	/^  std::vector<int> bias3, bias5;$/;"	m	struct:MinCollector
bias5	MinCollector.h	/^  std::vector<int> bias3, bias5;$/;"	m	struct:MinCollector
bias5	ProcessReads.h	/^  std::vector<int> bias5;$/;"	m	class:BUSProcessor
bias5	ProcessReads.h	/^  std::vector<int> bias5;$/;"	m	class:ReadProcessor
biasCount	ProcessReads.h	/^  std::atomic<int> biasCount;$/;"	m	class:MasterProcessor
bias_file	common.h	/^  std::string bias_file;$/;"	m	struct:ProgramOptions
binaryToString	BUSData.cpp	/^std::string binaryToString(uint64_t x, size_t len) {$/;"	f
bmix64	hash.cpp	/^inline void bmix64 ( uint64_t& h1, uint64_t& h2, uint64_t& k1, uint64_t& k2, uint64_t& c1, uint64_t& c2 ) {$/;"	f
bootstrap	common.h	/^  int bootstrap;$/;"	m	struct:ProgramOptions
breakpoints	ProcessReads.h	/^  std::vector<uint64_t> breakpoints;$/;"	m	class:MasterProcessor
bs_	H5Writer.h	/^    hid_t bs_;$/;"	m	class:H5Converter
bs_	H5Writer.h	/^    hid_t bs_;$/;"	m	class:H5Writer
buffer	ProcessReads.h	/^  char *buffer;$/;"	m	class:AlnProcessor
buffer	ProcessReads.h	/^  char *buffer;$/;"	m	class:BUSProcessor
buffer	ProcessReads.h	/^  char *buffer;$/;"	m	class:ReadProcessor
bufsize	ProcessReads.h	/^  size_t bufsize;$/;"	m	class:AlnProcessor
bufsize	ProcessReads.h	/^  size_t bufsize;$/;"	m	class:BUSProcessor
bufsize	ProcessReads.h	/^  size_t bufsize;$/;"	m	class:MasterProcessor
bufsize	ProcessReads.h	/^  size_t bufsize;$/;"	m	class:ReadProcessor
busOptions	common.h	/^  BUSOptions busOptions;$/;"	m	struct:ProgramOptions
bus_bc_len	ProcessReads.h	/^  int bus_bc_len[33];$/;"	m	class:MasterProcessor
bus_ecmap	ProcessReads.h	/^  EcMap bus_ecmap;$/;"	m	class:MasterProcessor
bus_ecmapinv	ProcessReads.h	/^  std::unordered_map<std::vector<int>, int, SortedVectorHasher> bus_ecmapinv;$/;"	m	class:MasterProcessor
bus_mode	common.h	/^  bool bus_mode;$/;"	m	struct:ProgramOptions
bus_umi_len	ProcessReads.h	/^  int bus_umi_len[33];$/;"	m	class:MasterProcessor
busf_out	ProcessReads.h	/^  std::ofstream busf_out;$/;"	m	class:MasterProcessor
bv	ProcessReads.h	/^  std::vector<BUSData> bv;$/;"	m	class:BUSProcessor
bytes	Kmer.hpp	/^    uint8_t bytes[MAX_K\/4];$/;"	m	union:Kmer::__anon1
calc_eff_lens	weights.cpp	/^std::vector<double> calc_eff_lens(const std::vector<int>& lengths, double mean)$/;"	f
calc_eff_lens	weights.cpp	/^std::vector<double> calc_eff_lens(const std::vector<int>& lengths,$/;"	f
calc_weights	weights.cpp	/^WeightMap calc_weights($/;"	f
call_	H5Writer.h	/^    std::string call_;$/;"	m	class:H5Converter
charToStrand	GeneModel.cpp	/^bool charToStrand(char c) {$/;"	f
checkFileExists	main.cpp	/^bool checkFileExists(std::string fn) {$/;"	f
checkMapability	Fusion.hpp	/^bool checkMapability(const KmerIndex& index, const std::string &s, const std::vector<std::pair<KmerEntry,int>>& v, std::vector<int> &u) {$/;"	f
checkUnionIntersection	Fusion.hpp	/^bool checkUnionIntersection(const KmerIndex& index, const std::string &s1, const std::string &s2, std::pair<int,int> &p1, std::pair<int,int> &p2) { $/;"	f
chr	GeneModel.h	/^  int chr; \/\/ chr number i based on bam header$/;"	m	struct:TranscriptAlignment
chr	GeneModel.h	/^  int chr;$/;"	m	struct:ExonModel
chr	GeneModel.h	/^  int chr;$/;"	m	struct:GeneModel
chr	GeneModel.h	/^  int chr;$/;"	m	struct:TranscriptModel
chr	GeneModel.h	/^  std::vector<Chromosome> chr;$/;"	m	struct:Transcriptome
chr	Inspect.h	/^  int chr;$/;"	m	struct:ECStruct
chrLookup	GeneModel.cpp	/^int chrLookup(const Transcriptome& model, const std::string chr) {$/;"	f
chrNameToId	GeneModel.h	/^  std::unordered_map<std::string, int> chrNameToId;$/;"	m	struct:Transcriptome
chromFile	common.h	/^  std::string chromFile;$/;"	m	struct:ProgramOptions
chrpos	GeneModel.h	/^  int chrpos; \/\/ 0-based position of left-most bp$/;"	m	struct:TranscriptAlignment
cigar	GeneModel.h	/^  std::vector<uint32_t> cigar; \/\/ the cigar ops that determine the alignment$/;"	m	struct:TranscriptAlignment
clear	KmerHashTable.h	/^  void clear() {$/;"	f	struct:KmerHashTable
clear	KmerIndex.cpp	/^void KmerIndex::clear() {$/;"	f	class:KmerIndex
clear	ProcessReads.cpp	/^void AlnProcessor::clear() {$/;"	f	class:AlnProcessor
clear	ProcessReads.cpp	/^void BUSProcessor::clear() {$/;"	f	class:BUSProcessor
clear	ProcessReads.cpp	/^void ReadProcessor::clear() {$/;"	f	class:ReadProcessor
clear_table	KmerHashTable.h	/^  void clear_table() {$/;"	f	struct:KmerHashTable
collect	MinCollector.cpp	/^int MinCollector::collect(std::vector<std::pair<KmerEntry,int>>& v1,$/;"	f	class:MinCollector
collect	MinCollector.h	/^  int collect(std::vector<std::pair<KmerEntry,int>>& v1) {$/;"	f	struct:MinCollector
commonName	GeneModel.h	/^  std::string commonName; \/\/ like ALB$/;"	m	struct:GeneModel
compression_	H5Writer.h	/^    uint compression_;$/;"	m	class:H5Writer
compute_mean_frag_lens_trunc	MinCollector.cpp	/^void MinCollector::compute_mean_frag_lens_trunc(bool verbose)  {$/;"	f	class:MinCollector
compute_rho	EMAlgorithm.h	/^  void compute_rho() {$/;"	f	struct:EMAlgorithm
const_iterator	KmerHashTable.h	/^  typedef iterator_<true> const_iterator;$/;"	t	struct:KmerHashTable
contig	KmerIndex.h	/^  int32_t contig; \/\/ id of contig$/;"	m	struct:KmerEntry
contigHasTrid	KmerIndex.cpp	/^bool contigHasTrid(std::vector<ContigToTranscript>& trans, int trid) {$/;"	f
contig_length	KmerIndex.h	/^  int32_t contig_length;$/;"	m	struct:KmerEntry
contigs	KmerIndex.h	/^  std::vector<Contig> contigs; \/\/ contig id -> contig$/;"	m	struct:DBGraph
conv	common.h	/^  int conv;$/;"	m	struct:ProgramOptions
convergence	EMAlgorithm.h	/^  double convergence(int conv) {$/;"	f	struct:EMAlgorithm
convert	H5Writer.cpp	/^void H5Converter::convert() {$/;"	f	class:H5Converter
convert_ornament_to_snps	KmerIndex.cpp	/^void KmerIndex::convert_ornament_to_snps($/;"	f	class:KmerIndex
convert_string_to_arr	KmerIndex.cpp	/^void KmerIndex::convert_string_to_arr(std::string variant_info, std::vector<int>& arr) const {$/;"	f	class:KmerIndex
count	BUSData.h	/^  uint32_t count;$/;"	m	struct:BUSData
countBias	MinCollector.cpp	/^bool MinCollector::countBias(const char *s1, const char *s2, const std::vector<std::pair<KmerEntry,int>> v1, const std::vector<std::pair<KmerEntry,int>> v2, bool paired) {$/;"	f	class:MinCollector
countBias	MinCollector.cpp	/^bool MinCollector::countBias(const char *s1, const char *s2, const std::vector<std::pair<KmerEntry,int>> v1, const std::vector<std::pair<KmerEntry,int>> v2, bool paired, std::vector<int>& biasOut) const {$/;"	f	class:MinCollector
counts	MinCollector.h	/^  std::vector<int> counts;$/;"	m	struct:MinCollector
counts	Multinomial.hpp	/^        const std::vector<int>& counts() { return counts_; }$/;"	f	class:Multinomial
counts	ProcessReads.h	/^  std::vector<int> counts;$/;"	m	class:BUSProcessor
counts	ProcessReads.h	/^  std::vector<int> counts;$/;"	m	class:ReadProcessor
counts_	EMAlgorithm.h	/^  const std::vector<int>& counts_;$/;"	m	struct:EMAlgorithm
counts_	Multinomial.hpp	/^        const std::vector<int>& counts_;$/;"	m	class:Multinomial
counts_to_tpm	PlaintextWriter.cpp	/^std::vector<double> counts_to_tpm(const std::vector<double>& est_counts,$/;"	f
createPseudoBamHeaderGenome	PseudoBam.cpp	/^bam_hdr_t* createPseudoBamHeaderGenome(const Transcriptome& model)  {$/;"	f
createPseudoBamHeaderTrans	PseudoBam.cpp	/^bam_hdr_t* createPseudoBamHeaderTrans(const KmerIndex& index)  {$/;"	f
current_file	ProcessReads.h	/^  int current_file;$/;"	m	class:FastqSequenceReader
dbGraph	KmerIndex.h	/^  DBGraph dbGraph;$/;"	m	struct:KmerIndex
dd_	Multinomial.hpp	/^        std::discrete_distribution<int> dd_;$/;"	m	class:Multinomial
decreaseCount	MinCollector.cpp	/^int MinCollector::decreaseCount(const int ec) {$/;"	f	class:MinCollector
default_genome_auxlen	ProcessReads.cpp	/^const int default_genome_auxlen = 7; \/\/ for ZW:f:0.0$/;"	v
default_trans_auxlen	ProcessReads.cpp	/^const int default_trans_auxlen = 14; \/\/ for NI:i:int and ZW:f:0.0$/;"	v
deleted	KmerHashTable.h	/^  value_type deleted;$/;"	m	struct:KmerHashTable
delta_length	KmerIndex.h	/^    int delta_length() const {$/;"	f	struct:VariantParameterEntry
ec	BUSData.h	/^  int32_t ec;$/;"	m	struct:BUSData
ec	Inspect.h	/^  int ec;$/;"	m	struct:ECStruct
ec	KmerIndex.h	/^  int ec;$/;"	m	struct:Contig
ec_id	PseudoBam.h	/^  int32_t ec_id;$/;"	m	struct:PseudoAlignmentInfo
ec_umi	ProcessReads.h	/^  std::vector<std::pair<int, std::string>> ec_umi;$/;"	m	class:AlnProcessor
ec_umi	ProcessReads.h	/^  std::vector<std::pair<int, std::string>> ec_umi;$/;"	m	class:ReadProcessor
ecmap	KmerIndex.h	/^  EcMap ecmap;$/;"	m	struct:KmerIndex
ecmap_	EMAlgorithm.h	/^  const EcMap& ecmap_;$/;"	m	struct:EMAlgorithm
ecmapinv	KmerIndex.h	/^  std::unordered_map<std::vector<int>, int, SortedVectorHasher> ecmapinv;$/;"	m	struct:KmerIndex
ecs	BUSData.h	/^  std::vector<std::vector<int32_t>> ecs;$/;"	m	struct:BUSHeader
ecs	KmerIndex.h	/^  std::vector<int> ecs; \/\/ contig id -> ec-id$/;"	m	struct:DBGraph
effParamsBias	MinCollector.h	/^  std::unordered_map<int, double> effParamsBias;$/;"	m	struct:MinCollector
eff_lengths_	H5Writer.h	/^    std::vector<double> eff_lengths_;$/;"	m	class:H5Converter
eff_lens_	Bootstrap.h	/^    const std::vector<double>& eff_lens_;$/;"	m	class:BootstrapThreadPool
eff_lens_	Bootstrap.h	/^  const std::vector<double>& eff_lens_;$/;"	m	class:Bootstrap
eff_lens_	EMAlgorithm.h	/^  std::vector<double> eff_lens_;$/;"	m	struct:EMAlgorithm
eff_lens_left_	EMAlgorithm.h	/^  std::vector<double> eff_lens_left_;$/;"	m	struct:EMAlgorithm
eff_lens_right_	EMAlgorithm.h	/^  std::vector<double> eff_lens_right_;$/;"	m	struct:EMAlgorithm
eff_nv_weights_	EMAlgorithm.h	/^  std::vector<double> eff_nv_weights_;$/;"	m	struct:EMAlgorithm
effectiveASEParams	KmerIndex.h	/^  std::unordered_map<int, std::vector<VariantParameterEntry>> effectiveASEParams;$/;"	m	struct:KmerIndex
em	ProcessReads.h	/^  const EMAlgorithm& em;$/;"	m	class:AlnProcessor
empty	KmerHashTable.h	/^  value_type empty;$/;"	m	struct:KmerHashTable
empty	ProcessReads.cpp	/^bool BamSequenceReader::empty() {$/;"	f	class:BamSequenceReader
empty	ProcessReads.cpp	/^bool FastqSequenceReader::empty() {$/;"	f	class:FastqSequenceReader
end	KmerHashTable.h	/^  const_iterator end() const {$/;"	f	struct:KmerHashTable
end	KmerHashTable.h	/^  iterator end() {$/;"	f	struct:KmerHashTable
eps	EMAlgorithm.h	/^const double eps = 1e-08;$/;"	v
erase	KmerHashTable.h	/^  iterator erase(const_iterator pos) {$/;"	f	struct:KmerHashTable
erase	KmerHashTable.h	/^  size_t erase(const Kmer& km) {$/;"	f	struct:KmerHashTable
err	ProcessReads.h	/^  int err;$/;"	m	class:BamSequenceReader
eseq	ProcessReads.h	/^  uint8_t *eseq;$/;"	m	class:BamSequenceReader
exons	GeneModel.h	/^  std::vector<ExonModel> exons;$/;"	m	struct:TranscriptModel
f_umi	ProcessReads.h	/^  std::unique_ptr<std::ifstream> f_umi;$/;"	m	class:FastqSequenceReader
fetchSequences	ProcessReads.cpp	/^bool BamSequenceReader::fetchSequences(char *buf, const int limit, std::vector<std::pair<const char *, int> > &seqs,$/;"	f	class:BamSequenceReader
fetchSequences	ProcessReads.cpp	/^bool FastqSequenceReader::fetchSequences(char *buf, const int limit, std::vector<std::pair<const char *, int> > &seqs,$/;"	f	class:FastqSequenceReader
file_id_	H5Writer.h	/^    hid_t file_id_;$/;"	m	class:H5Converter
file_id_	H5Writer.h	/^    hid_t file_id_;$/;"	m	class:H5Writer
fileno	common.h	/^  int fileno;$/;"	m	struct:BUSOptionSubstr
files	ProcessReads.h	/^  std::vector<std::string> files;$/;"	m	class:FastqSequenceReader
files	common.h	/^  std::vector<std::string> files;$/;"	m	struct:ProgramOptions
fillBamRecord	ProcessReads.cpp	/^int fillBamRecord(bam1_t &b, uint8_t* buf, const char *seq, const char *name, const char *qual, int slen, int nlen, bool unmapped, int auxlen) {$/;"	f
filterVariants	KmerIndex.cpp	/^void KmerIndex::filterVariants(const ProgramOptions& opt, bool filter_phased) {$/;"	f	class:KmerIndex
find	KmerHashTable.h	/^  const_iterator find(const Kmer& key) const {$/;"	f	struct:KmerHashTable
find	KmerHashTable.h	/^  iterator find(const Kmer& key) {$/;"	f	struct:KmerHashTable
findEC	MinCollector.cpp	/^int MinCollector::findEC(const std::vector<int>& u) const {$/;"	f	class:MinCollector
findFirstMappingKmer	ProcessReads.cpp	/^int findFirstMappingKmer(const std::vector<std::pair<KmerEntry,int>> &v,KmerEntry &val) {$/;"	f
findFirstOrnamentAgnosticPosition	KmerIndex.cpp	/^std::pair<int, bool> KmerIndex::findFirstOrnamentAgnosticPosition(int tr, Kmer km, KmerEntry& val, int p) const {$/;"	f	class:KmerIndex
findPosition	KmerIndex.cpp	/^std::pair<int,bool> KmerIndex::findPosition(int tr, Kmer km, KmerEntry val, int p) const {$/;"	f	class:KmerIndex
findPosition	KmerIndex.cpp	/^std::pair<int,bool> KmerIndex::findPosition(int tr, Kmer km, int p) const {$/;"	f	class:KmerIndex
findVC	MinCollector.cpp	/^int MinCollector::findVC(const std::pair<std::vector<int>, std::vector<int>>& p) const {$/;"	f	class:MinCollector
find_first	KmerHashTable.h	/^    void find_first() {$/;"	f	class:KmerHashTable::iterator_
find_next	KmerIterator.cpp	/^void KmerIterator::find_next(size_t i, size_t j, bool last_valid) {$/;"	f	class:KmerIterator
fixCigarStringGenome	ProcessReads.cpp	/^void fixCigarStringGenome(bam1_t &b, const TranscriptAlignment& tra) {$/;"	f
fixCigarStringTrans	ProcessReads.cpp	/^void fixCigarStringTrans(bam1_t &b, int rlen, int softclip, int overhang) {$/;"	f
flags	BUSData.h	/^  uint32_t flags;  $/;"	m	struct:BUSData
flags	ProcessReads.h	/^  std::vector<uint32_t> flags;$/;"	m	class:AlnProcessor
flags	ProcessReads.h	/^  std::vector<uint32_t> flags;$/;"	m	class:BUSProcessor
flags	ProcessReads.h	/^  std::vector<uint32_t> flags;$/;"	m	class:ReadProcessor
fld	common.h	/^  double fld;$/;"	m	struct:ProgramOptions
flens	MinCollector.h	/^  std::vector<int> flens;$/;"	m	struct:MinCollector
flens	ProcessReads.h	/^  std::vector<int> flens;$/;"	m	class:BUSProcessor
flens	ProcessReads.h	/^  std::vector<int> flens;$/;"	m	class:ReadProcessor
fmix64	hash.cpp	/^inline uint64_t fmix64 ( uint64_t k ) {$/;"	f
forwardBase	Kmer.cpp	/^Kmer Kmer::forwardBase(const char b) const {$/;"	f	class:Kmer
fp	ProcessReads.h	/^  BGZF *fp;$/;"	m	class:BamSequenceReader
fp	ProcessReads.h	/^  std::vector<gzFile> fp;$/;"	m	class:FastqSequenceReader
fusion	common.h	/^  bool fusion;$/;"	m	struct:ProgramOptions
fwStep	KmerIndex.cpp	/^bool KmerIndex::fwStep(Kmer km, Kmer& end) const {$/;"	f	class:KmerIndex
gen_	Multinomial.hpp	/^        std::default_random_engine gen_;$/;"	m	class:Multinomial
geneNameToId	GeneModel.h	/^  std::unordered_map<std::string, int> geneNameToId;$/;"	m	struct:Transcriptome
gene_id	GeneModel.h	/^  int gene_id;$/;"	m	struct:TranscriptModel
genes	GeneModel.h	/^  std::vector<GeneModel> genes;$/;"	m	struct:Transcriptome
genomebam	common.h	/^  bool genomebam;$/;"	m	struct:ProgramOptions
get16bits	hash.hpp	12;"	d
get16bits	hash.hpp	5;"	d
get16bits	hash.hpp	8;"	d
getBCLength	common.h	/^  int getBCLength() const {$/;"	f	struct:BUSOptions
getBinary	Kmer.cpp	/^std::string Kmer::getBinary() const {$/;"	f	class:Kmer
getCIGARandSoftClip	PseudoBam.cpp	/^void getCIGARandSoftClip(char* cig, bool strand, bool mapped, int &posread, int &posmate, int length, int targetlength) {$/;"	f
getDist	KmerIndex.h	/^  inline int getDist(bool fw) const {$/;"	f	struct:KmerEntry
getLink	Kmer.cpp	/^Kmer Kmer::getLink(const size_t index) const {$/;"	f	class:Kmer
getPos	KmerIndex.h	/^  inline int getPos() const {return (_pos & 0x0FFFFFFF);}$/;"	f	struct:KmerEntry
getPositionInTranscript	MinCollector.cpp	/^int getPositionInTranscript(Contig& c, KmerEntry& ke, Kmer& km, ContigToTranscript& ctt) {$/;"	f
getTranscriptNamesForKmer	KmerIndex.cpp	/^std::vector<std::string> KmerIndex::getTranscriptNamesForKmer(const char* kmer) {$/;"	f	class:KmerIndex
getUMILength	common.h	/^  int getUMILength() const {$/;"	f	struct:BUSOptions
get_array_matches	KmerIndex.cpp	/^bool KmerIndex::get_array_matches(int start_pos, std::string t, std::string ornament, int orn_tid, int k) {$/;"	f	class:KmerIndex
get_datatype_id	h5utils.cpp	/^hid_t get_datatype_id(const std::vector<double>& v) {$/;"	f
get_datatype_id	h5utils.cpp	/^hid_t get_datatype_id(const std::vector<int>& v) {$/;"	f
get_datatype_id	h5utils.cpp	/^hid_t get_datatype_id(const std::vector<std::string>& v) {$/;"	f
get_frag_len_means	weights.cpp	/^std::vector<double> get_frag_len_means(const std::vector<int>& lengths,$/;"	f
get_local_time	main.cpp	/^std::string get_local_time() {$/;"	f
get_mean_frag_len	MinCollector.cpp	/^double MinCollector::get_mean_frag_len(bool lenient) const {$/;"	f	class:MinCollector
get_nonvariant_weight_map	EMAlgorithm.h	/^  std::vector<std::vector<double>> get_nonvariant_weight_map($/;"	f	struct:EMAlgorithm
get_ornament_position	KmerIndex.cpp	/^int KmerIndex::get_ornament_position(int shade) const {$/;"	f	class:KmerIndex
get_sd_frag_len	MinCollector.cpp	/^double MinCollector::get_sd_frag_len() const {$/;"	f	class:MinCollector
get_substring_positions	KmerIndex.cpp	/^std::vector<size_t> KmerIndex::get_substring_positions(std::string t, std::string ornament, int orn_tid, int k) {$/;"	f	class:KmerIndex
get_variant_map	EMAlgorithm.h	/^  std::vector<std::vector<double>> get_variant_map($/;"	f	struct:EMAlgorithm
getblock	hash.cpp	/^inline uint64_t getblock ( const uint64_t *p, int i ) {$/;"	f
gfa	common.h	/^  std::string gfa; \/\/ used for inspect$/;"	m	struct:ProgramOptions
gtfFile	common.h	/^  std::string gtfFile;$/;"	m	struct:ProgramOptions
h	KmerHashTable.h	/^    size_t h;$/;"	m	class:KmerHashTable::iterator_
hamming	KmerIndex.cpp	/^int hamming(const char *a, const char *b) {$/;"	f
has_mean_fl	MinCollector.h	/^  bool has_mean_fl;$/;"	m	struct:MinCollector
has_mean_fl_trunc	MinCollector.h	/^  bool has_mean_fl_trunc;$/;"	m	struct:MinCollector
hash	GeneModel.h	/^  struct hash<TranscriptAlignment> {$/;"	s	namespace:std
hash	GeneModel.h	/^  struct hash<std::pair<TranscriptAlignment, TranscriptAlignment>> {$/;"	s	namespace:std
hash	Kmer.cpp	/^uint64_t Kmer::hash() const {$/;"	f	class:Kmer
head	ProcessReads.h	/^  bam_hdr_t *head;$/;"	m	class:BamSequenceReader
hexamerToInt	MinCollector.cpp	/^int hexamerToInt(const char *s, bool revcomp) {$/;"	f
homo_alt_snps	KmerIndex.h	/^  std::unordered_map<int, std::unordered_set<int>> homo_alt_snps;$/;"	m	struct:KmerIndex
ht	KmerHashTable.h	/^    DataStructurePointerType ht;$/;"	m	class:KmerHashTable::iterator_
id	GeneModel.h	/^  int id;$/;"	m	struct:GeneModel
id	GeneModel.h	/^  int id;$/;"	m	struct:TranscriptModel
id	KmerIndex.h	/^  int id; \/\/ internal id$/;"	m	struct:Contig
id	ProcessReads.h	/^  int id;$/;"	m	class:AlnProcessor
id	ProcessReads.h	/^  int id;$/;"	m	class:BUSProcessor
id	ProcessReads.h	/^  int id;$/;"	m	class:ReadProcessor
id	PseudoBam.h	/^  int32_t id; \/\/ id local to batch$/;"	m	struct:PseudoAlignmentInfo
idx_version_	H5Writer.h	/^    size_t idx_version_;$/;"	m	class:H5Converter
increaseCount	MinCollector.cpp	/^int MinCollector::increaseCount(const std::vector<int>& u) {$/;"	f	class:MinCollector
increaseVCount	MinCollector.cpp	/^int MinCollector::increaseVCount(const variant_class& p) {$/;"	f	class:MinCollector
index	MinCollector.h	/^  KmerIndex& index;$/;"	m	struct:MinCollector
index	ProcessReads.h	/^  KmerIndex& index;$/;"	m	class:MasterProcessor
index	ProcessReads.h	/^  const KmerIndex& index;$/;"	m	class:AlnProcessor
index	ProcessReads.h	/^  const KmerIndex& index;$/;"	m	class:BUSProcessor
index	ProcessReads.h	/^  const KmerIndex& index;$/;"	m	class:ReadProcessor
index	common.h	/^  std::string index;$/;"	m	struct:ProgramOptions
indexTransform	EMAlgorithm.h	/^  std::vector<int> indexTransform; \/\/ transcript index to theta index$/;"	m	struct:EMAlgorithm
index_	Bootstrap.h	/^    const KmerIndex& index_;$/;"	m	class:BootstrapThreadPool
index_	Bootstrap.h	/^  const KmerIndex& index_;$/;"	m	class:Bootstrap
index_	EMAlgorithm.h	/^  const KmerIndex& index_;$/;"	m	struct:EMAlgorithm
init	H5Writer.cpp	/^void H5Writer::init(const std::string& fname, int num_bootstrap, int num_processed,$/;"	f	class:H5Writer
initRepeatTranscriptBiasCorrection	KmerIndex.cpp	/^void KmerIndex::initRepeatTranscriptBiasCorrection(std::string bias_file) {$/;"	f	class:KmerIndex
initVariantParamEntry	KmerIndex.cpp	/^void KmerIndex::initVariantParamEntry(std::string vcf_file, std::string sample, bool is_phased) {$/;"	f	class:KmerIndex
init_mean_fl_trunc	MinCollector.cpp	/^void MinCollector::init_mean_fl_trunc(double mean, double sd) {$/;"	f	class:MinCollector
init_table	KmerHashTable.h	/^  void init_table(size_t sz) {$/;"	f	struct:KmerHashTable
insert	KmerHashTable.h	/^  std::pair<iterator,bool> insert(const value_type& val) {$/;"	f	struct:KmerHashTable
inspect_thorough	common.h	/^  bool inspect_thorough;$/;"	m	struct:ProgramOptions
intersect	KmerIndex.cpp	/^std::vector<int> KmerIndex::intersect(int ec, const std::vector<int>& v) const {$/;"	f	class:KmerIndex
intersect	MinCollector.cpp	/^std::vector<int> intersect(const std::vector<int>& x, const std::vector<int>& y) {$/;"	f
intersectECs	MinCollector.cpp	/^std::vector<int> MinCollector::intersectECs(std::vector<std::pair<KmerEntry,int>>& v) const {$/;"	f	class:MinCollector
intersectKmers	MinCollector.cpp	/^int MinCollector::intersectKmers(std::vector<std::pair<KmerEntry,int>>& v1,$/;"	f	class:MinCollector
invalid_	KmerIterator.hpp	/^  bool invalid_;$/;"	m	class:KmerIterator
isFw	KmerIndex.h	/^  inline int isFw() const  {return (_pos & 0xF0000000) == 0; }$/;"	f	struct:KmerEntry
isSubset	ProcessReads.cpp	/^bool isSubset(const std::vector<int>& x, const std::vector<int>& y) {$/;"	f
isUnique	KmerIndex.cpp	/^bool isUnique(const std::vector<int>& u) {$/;"	f
isUniqueOrCompatible	MinCollector.cpp	/^int MinCollector::isUniqueOrCompatible($/;"	f	class:MinCollector
is_first	KmerIndex.h	/^    bool is_first;$/;"	m	struct:VariantParameterEntry
is_indel	KmerIndex.h	/^    bool is_indel() const {$/;"	f	struct:VariantParameterEntry
is_problem_transcript	KmerIndex.cpp	/^bool KmerIndex::is_problem_transcript(std::string t, std::string ornament, int orn_tid, int k) {$/;"	f	class:KmerIndex
iterations	common.h	/^  int iterations;$/;"	m	struct:ProgramOptions
iterator	KmerHashTable.h	/^  typedef iterator_<false> iterator;$/;"	t	struct:KmerHashTable
iterator_	KmerHashTable.h	/^    iterator_() : ht(nullptr), h(0) {}$/;"	f	class:KmerHashTable::iterator_
iterator_	KmerHashTable.h	/^    iterator_(DataStructurePointerType ht_) : ht(ht_), h(ht_->size_) {}$/;"	f	class:KmerHashTable::iterator_
iterator_	KmerHashTable.h	/^    iterator_(DataStructurePointerType ht_, size_t h_) :  ht(ht_), h(h_) {}$/;"	f	class:KmerHashTable::iterator_
iterator_	KmerHashTable.h	/^    iterator_(const iterator_<false>& o) : ht(o.ht), h(o.h) {}$/;"	f	class:KmerHashTable::iterator_
iterator_	KmerHashTable.h	/^  class iterator_ : public std::iterator<std::forward_iterator_tag, value_type> {$/;"	c	struct:KmerHashTable
jumpTo	KmerIterator.cpp	/^void KmerIterator::jumpTo(int pos) {$/;"	f	class:KmerIterator
k	Kmer.cpp	/^unsigned int Kmer::k = 0;$/;"	m	class:Kmer	file:
k	Kmer.hpp	/^  static unsigned int k;$/;"	m	class:Kmer
k	KmerIndex.h	/^  int k; \/\/ k-mer size used$/;"	m	struct:KmerIndex
k	MinCollector.h	/^  int k;$/;"	m	struct:MinCollector
k	common.h	/^  int k;$/;"	m	struct:ProgramOptions
k1pos	PseudoBam.h	/^  int k1pos; \/\/ -1 for not present, 0-based position of first mapping k-mer in read 1$/;"	m	struct:PseudoAlignmentInfo
k2pos	PseudoBam.h	/^  int k2pos;$/;"	m	struct:PseudoAlignmentInfo
k_bytes	Kmer.cpp	/^unsigned int Kmer::k_bytes = 0;$/;"	m	class:Kmer	file:
k_bytes	Kmer.hpp	/^  static unsigned int k_bytes;$/;"	m	class:Kmer
k_longs	Kmer.hpp	/^  static unsigned int k_longs;$/;"	m	class:Kmer
k_modmask	Kmer.cpp	/^unsigned int Kmer::k_modmask = 0;$/;"	m	class:Kmer	file:
k_modmask	Kmer.hpp	/^  static unsigned int k_modmask; \/\/ int?$/;"	m	class:Kmer
kal_id_	H5Writer.h	/^    std::vector<int> kal_id_;$/;"	m	class:H5Converter
kal_version_	H5Writer.h	/^    std::string kal_version_;$/;"	m	class:H5Converter
kmap	KmerIndex.h	/^  KmerHashTable<KmerEntry, KmerHash> kmap;$/;"	m	struct:KmerIndex
kroundup32	kseq.h	90;"	d
ks_eof	kseq.h	48;"	d
ks_err	kseq.h	47;"	d
ks_rewind	kseq.h	49;"	d
kseq_rewind	kseq.h	154;"	d
kstring_t	kseq.h	/^} kstring_t;$/;"	t	typeref:struct:__kstring_t
l	ProcessReads.h	/^  std::vector<int> l;$/;"	m	class:FastqSequenceReader
l	kseq.h	/^	size_t l, m;$/;"	m	struct:__kstring_t
l_bc	ProcessReads.h	/^  int l_bc;$/;"	m	class:BamSequenceReader
l_seq	ProcessReads.h	/^  int32_t l_seq;$/;"	m	class:BamSequenceReader
l_umi	ProcessReads.h	/^  int l_umi;$/;"	m	class:BamSequenceReader
last_pseudobatch_id	ProcessReads.h	/^  int last_pseudobatch_id;$/;"	m	class:MasterProcessor
len	GeneModel.h	/^  int len;$/;"	m	struct:Chromosome
length	GeneModel.h	/^  int length;$/;"	m	struct:TranscriptModel
length	KmerIndex.h	/^  int length; \/\/ number of k-mers$/;"	m	struct:Contig
lengths_	H5Writer.h	/^    std::vector<int> lengths_;$/;"	m	class:H5Converter
load	KmerIndex.cpp	/^void KmerIndex::load(ProgramOptions& opt, bool loadKmerTable) {$/;"	f	class:KmerIndex
loadChromosomes	GeneModel.cpp	/^void Transcriptome::loadChromosomes(const std::string &chrom_fn) {$/;"	f	class:Transcriptome
loadCounts	MinCollector.cpp	/^void MinCollector::loadCounts(ProgramOptions& opt) {$/;"	f	class:MinCollector
loadTranscriptSequences	KmerIndex.cpp	/^void KmerIndex::loadTranscriptSequences() const {$/;"	f	class:KmerIndex
load_eff_weights_from_file	EMAlgorithm.h	/^  std::unordered_map<std::string, int> load_eff_weights_from_file(std::string file) {$/;"	f	struct:EMAlgorithm
load_transcript_weights	KmerIndex.cpp	/^std::unordered_map<std::string, double> load_transcript_weights(std::string file_name, char delim) {$/;"	f
local_id	ProcessReads.h	/^  int local_id;$/;"	m	class:BUSProcessor
local_id	ProcessReads.h	/^  int local_id;$/;"	m	class:ReadProcessor
longs	Kmer.hpp	/^    uint64_t longs[MAX_K\/32];$/;"	m	union:Kmer::__anon1
ltrim	KmerIndex.cpp	/^static inline void ltrim(std::string &s) {$/;"	f	file:
m	kseq.h	/^	size_t l, m;$/;"	m	struct:__kstring_t
main	main.cpp	/^int main(int argc, char *argv[]) {$/;"	f
make_unique	common.h	/^  bool make_unique;$/;"	m	struct:ProgramOptions
mapPair	KmerIndex.cpp	/^int KmerIndex::mapPair(const char *s1, int l1, const char *s2, int l2, int ec) const {$/;"	f	class:KmerIndex
match	KmerIndex.cpp	/^void KmerIndex::match(const char *s, int l, std::vector<std::pair<KmerEntry, int>>& v) const {$/;"	f	class:KmerIndex
maxBiasCount	ProcessReads.h	/^  const int maxBiasCount;$/;"	m	class:MasterProcessor
mean_fl	MinCollector.h	/^  double mean_fl;$/;"	m	struct:MinCollector
mean_fl_trunc	MinCollector.h	/^  std::vector<double> mean_fl_trunc;$/;"	m	struct:MinCollector
mean_fls_	Bootstrap.h	/^    const std::vector<double>& mean_fls_;$/;"	m	class:BootstrapThreadPool
mean_fls_	Bootstrap.h	/^  const std::vector<double>& mean_fls_;$/;"	m	class:Bootstrap
merge_contigs	Inspect.h	/^std::vector<ECStruct> merge_contigs(std::vector<ECStruct> ecv) {$/;"	f
min_range	MinCollector.h	/^  int min_range;$/;"	m	struct:MinCollector
min_range	common.h	/^  int min_range;$/;"	m	struct:ProgramOptions
model	ProcessReads.h	/^  const Transcriptome& model;$/;"	m	class:AlnProcessor
model	ProcessReads.h	/^  const Transcriptome& model;$/;"	m	class:MasterProcessor
mp	ProcessReads.h	/^  MasterProcessor& mp;$/;"	m	class:AlnProcessor
mp	ProcessReads.h	/^  MasterProcessor& mp;$/;"	m	class:BUSProcessor
mp	ProcessReads.h	/^  MasterProcessor& mp;$/;"	m	class:ReadProcessor
mult_	Bootstrap.h	/^  Multinomial mult_;$/;"	m	class:Bootstrap
my_mkdir	main.cpp	/^int my_mkdir(const char *path, mode_t mode) {$/;"	f
n	Multinomial.hpp	/^        int n() const { return n_; }$/;"	f	class:Multinomial
n_	Multinomial.hpp	/^        int n_;$/;"	m	class:Multinomial
n_bs_	H5Writer.h	/^    int n_bs_;$/;"	m	class:H5Converter
n_complete_	Bootstrap.h	/^    size_t n_complete_;$/;"	m	class:BootstrapThreadPool
n_paln_	H5Writer.h	/^    int n_paln_;$/;"	m	class:H5Converter
n_proc_	H5Writer.h	/^    int n_proc_;$/;"	m	class:H5Converter
n_targs_	H5Writer.h	/^    size_t n_targs_;$/;"	m	class:H5Converter
n_threads_	Bootstrap.h	/^    size_t n_threads_;$/;"	m	class:BootstrapThreadPool
name	BUSData.h	/^  std::string name;$/;"	m	struct:BUSTranscript
name	GeneModel.h	/^  std::string name; \/\/ like ENSG$/;"	m	struct:GeneModel
name	GeneModel.h	/^  std::string name; \/\/ like ENST  $/;"	m	struct:TranscriptModel
name	GeneModel.h	/^  std::string name;$/;"	m	struct:Chromosome
names	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> names;$/;"	m	class:AlnProcessor
names	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> names;$/;"	m	class:BUSProcessor
names	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> names;$/;"	m	class:ReadProcessor
newB	ProcessReads.h	/^  std::vector<std::pair<BUSData, std::vector<int32_t>>> newB;$/;"	m	class:BUSProcessor
newBatchECcount	ProcessReads.h	/^  std::vector<std::unordered_map<std::vector<int>, int, SortedVectorHasher>> newBatchECcount;$/;"	m	class:MasterProcessor
newBatchECumis	ProcessReads.h	/^  std::vector<std::vector<std::pair<std::vector<int>, std::string>>> newBatchECumis;$/;"	m	class:MasterProcessor
newBiasMap	ProcessReads.h	/^  std::unordered_map<int, double> newBiasMap;$/;"	m	class:ReadProcessor
newECcount	ProcessReads.h	/^  std::unordered_map<std::vector<int>, int, SortedVectorHasher> newECcount;$/;"	m	class:MasterProcessor
newEcs	ProcessReads.h	/^  std::vector<std::vector<int>> newEcs;$/;"	m	class:BUSProcessor
newEcs	ProcessReads.h	/^  std::vector<std::vector<int>> newEcs;$/;"	m	class:ReadProcessor
newVEcs	ProcessReads.h	/^  std::vector<variant_class> newVEcs;$/;"	m	class:ReadProcessor
new_ec_umi	ProcessReads.h	/^  std::vector<std::pair<std::vector<int>, std::string>> new_ec_umi;$/;"	m	class:ReadProcessor
nfiles	ProcessReads.h	/^  int nfiles = 1;$/;"	m	class:FastqSequenceReader
nfiles	common.h	/^  int nfiles;$/;"	m	struct:BUSOptions
nl	ProcessReads.h	/^  std::vector<int> nl;$/;"	m	class:FastqSequenceReader
nonvariant	MinCollector.cpp	/^enum RefInfo { ref, alt, alt2, nonvariant };$/;"	e	enum:RefInfo	file:
num	ProcessReads.h	/^  bool num;$/;"	m	class:BUSProcessor
num	common.h	/^  bool num;$/;"	m	struct:ProgramOptions
numSortFiles	ProcessReads.h	/^  const int numSortFiles = 32;$/;"	m	class:MasterProcessor
num_bootstrap_	H5Writer.h	/^    int num_bootstrap_;$/;"	m	class:H5Writer
num_eq	KmerIndex.cpp	/^int num_eq(int start_pos, int num_comp, int k, std::string s1, std::string s2) {$/;"	f
num_threads	Bootstrap.h	/^    size_t num_threads() {return n_threads_;}$/;"	f	class:BootstrapThreadPool
num_trans	KmerIndex.h	/^  int num_trans; \/\/ number of targets$/;"	m	struct:KmerIndex
num_trans_	EMAlgorithm.h	/^  int num_trans_;$/;"	m	struct:EMAlgorithm
num_umi	ProcessReads.h	/^  int64_t num_umi;$/;"	m	class:MasterProcessor
nummapped	ProcessReads.h	/^  int64_t nummapped;$/;"	m	class:MasterProcessor
numreads	ProcessReads.h	/^  int64_t numreads;$/;"	m	class:AlnProcessor
numreads	ProcessReads.h	/^  int64_t numreads;$/;"	m	class:BUSProcessor
numreads	ProcessReads.h	/^  int64_t numreads;$/;"	m	class:MasterProcessor
numreads	ProcessReads.h	/^  int64_t numreads;$/;"	m	class:ReadProcessor
numreads	ProcessReads.h	/^  uint32_t numreads = 0;$/;"	m	class:FastqSequenceReader
ofusion	ProcessReads.h	/^  std::ofstream ofusion;$/;"	m	class:MasterProcessor
operator !=	Kmer.hpp	/^  bool operator!=(const Kmer& o) const {$/;"	f	class:Kmer
operator !=	KmerHashTable.h	/^    bool operator!=(const iterator_ &o) const {return !(this->operator==(o));}$/;"	f	class:KmerHashTable::iterator_
operator !=	KmerIterator.hpp	/^  bool operator!=(const KmerIterator& o) { return !this->operator==(o);}$/;"	f	class:KmerIterator
operator ()	Bootstrap.cpp	/^void BootstrapWorker::operator() (){$/;"	f	class:BootstrapWorker
operator ()	EMAlgorithm.h	/^    size_t operator()(const std::pair<int, int>& p) const {$/;"	f	struct:SortedIntPairHasher
operator ()	GeneModel.h	/^      inline size_t operator()(const TranscriptAlignment& x) const {$/;"	f	struct:std::hash
operator ()	GeneModel.h	/^      inline size_t operator()(const std::pair<TranscriptAlignment, TranscriptAlignment>& x) const {$/;"	f	struct:std::hash
operator ()	Kmer.hpp	/^  size_t operator()(const Kmer& km) const {$/;"	f	struct:KmerHash
operator ()	KmerIndex.h	/^  size_t operator()(const std::pair<std::vector<int>, std::vector<int>>& p) const {$/;"	f	struct:SortedVectorPairHasher
operator ()	KmerIndex.h	/^  size_t operator()(const std::vector<int>& v) const {$/;"	f	struct:SortedVectorHasher
operator ()	MinCollector.cpp	/^  bool operator()(std::pair<KmerEntry,int> a, std::pair<KmerEntry,int> b) {$/;"	f	struct:ComparePairsBySecond
operator ()	ProcessReads.cpp	/^void AlnProcessor::operator()() {$/;"	f	class:AlnProcessor
operator ()	ProcessReads.cpp	/^void BUSProcessor::operator()() {$/;"	f	class:BUSProcessor
operator ()	ProcessReads.cpp	/^void ReadProcessor::operator()() {$/;"	f	class:ReadProcessor
operator *	KmerHashTable.h	/^    ValueReferenceType operator*() const {return ht->table[h];}$/;"	f	class:KmerHashTable::iterator_
operator *	KmerIterator.cpp	/^std::pair<Kmer, int>& KmerIterator::operator*() {$/;"	f	class:KmerIterator
operator ++	KmerHashTable.h	/^    iterator_ operator++(int) {$/;"	f	class:KmerHashTable::iterator_
operator ++	KmerHashTable.h	/^    iterator_& operator++() {$/;"	f	class:KmerHashTable::iterator_
operator ++	KmerIterator.cpp	/^KmerIterator KmerIterator::operator++(int) {$/;"	f	class:KmerIterator
operator ++	KmerIterator.cpp	/^KmerIterator& KmerIterator::operator++() {$/;"	f	class:KmerIterator
operator ->	KmerHashTable.h	/^    ValuePointerType operator->() const {return &(ht->table[h]);}$/;"	f	class:KmerHashTable::iterator_
operator ->	KmerIterator.cpp	/^std::pair<Kmer, int> *KmerIterator::operator->() {$/;"	f	class:KmerIterator
operator <	Kmer.cpp	/^bool Kmer::operator<(const Kmer& o) const {$/;"	f	class:Kmer
operator <<	EMAlgorithm.h	/^std::ostream & operator<<(std::ostream & os, std::vector<T> vec)$/;"	f
operator <<	KmerIndex.cpp	/^std::ostream & operator<<(std::ostream & os, std::vector<T> vec)$/;"	f
operator <<	MinCollector.cpp	/^std::ostream & operator<<(std::ostream & os, std::vector<T> vec)$/;"	f
operator =	Kmer.cpp	/^Kmer& Kmer::operator=(const Kmer& o) {$/;"	f	class:Kmer
operator =	KmerHashTable.h	/^    iterator_& operator=(const iterator_& o) {ht=o.ht; h=o.h; return *this;}$/;"	f	class:KmerHashTable::iterator_
operator ==	GeneModel.h	/^  inline bool operator==(const TranscriptAlignment& o) const {$/;"	f	struct:TranscriptAlignment
operator ==	Kmer.hpp	/^  inline bool operator==(const Kmer& o) const {$/;"	f	class:Kmer
operator ==	KmerHashTable.h	/^    bool operator==(const iterator_ &o) const {return (ht->table == o.ht->table) && (h == o.h);}$/;"	f	class:KmerHashTable::iterator_
operator ==	KmerIterator.cpp	/^bool KmerIterator::operator==(const KmerIterator& o) {$/;"	f	class:KmerIterator
opt	Bootstrap.h	/^  const ProgramOptions& opt;$/;"	m	class:Bootstrap
opt	EMAlgorithm.h	/^  const ProgramOptions& opt;$/;"	m	struct:EMAlgorithm
opt	ProcessReads.h	/^  const ProgramOptions& opt;$/;"	m	class:MasterProcessor
opt_	Bootstrap.h	/^    const ProgramOptions& opt_;$/;"	m	class:BootstrapThreadPool
orientation	KmerIndex.h	/^    char orientation;$/;"	m	struct:VariantParameterEntry
orientation	MinCollector.h	/^  char orientation;$/;"	m	struct:BiasWeightStruct
out_dir_	H5Writer.h	/^    std::string out_dir_;$/;"	m	class:H5Converter
output	common.h	/^  std::string output;$/;"	m	struct:ProgramOptions
outputFusion	ProcessReads.cpp	/^void MasterProcessor::outputFusion(const std::stringstream &o) {$/;"	f	class:MasterProcessor
outputPseudoBam	PseudoBam.cpp	/^void outputPseudoBam(const KmerIndex &index, const std::vector<int> &u,$/;"	f
p_	KmerIterator.hpp	/^  std::pair<Kmer, int> p_;$/;"	m	class:KmerIterator
pad	BUSData.h	/^  uint32_t pad;$/;"	m	struct:BUSData
paired	ProcessReads.h	/^  bool paired;$/;"	m	class:AlnProcessor
paired	ProcessReads.h	/^  bool paired;$/;"	m	class:BUSProcessor
paired	ProcessReads.h	/^  bool paired;$/;"	m	class:FastqSequenceReader
paired	ProcessReads.h	/^  bool paired;$/;"	m	class:ReadProcessor
paired	PseudoBam.h	/^  bool paired;  \/\/ 1$/;"	m	struct:PseudoAlignmentInfo
parseGTF	GeneModel.cpp	/^void Transcriptome::parseGTF(const std::string &gtf_fn, const KmerIndex& index, const ProgramOptions& options, bool guessChromosomes) {$/;"	f	class:Transcriptome
pdenoms	EMAlgorithm.h	/^  std::vector<double> pdenoms;$/;"	m	struct:EMAlgorithm
peek	common.h	/^  bool peek; \/\/ only used for H5Dump$/;"	m	struct:ProgramOptions
phased	common.h	/^  bool phased;$/;"	m	struct:ProgramOptions
plaintext	common.h	/^  bool plaintext;$/;"	m	struct:ProgramOptions
plaintext_aux	PlaintextWriter.cpp	/^void plaintext_aux($/;"	f
plaintext_writer	PlaintextWriter.cpp	/^void plaintext_writer($/;"	f
pool_	Bootstrap.h	/^    BootstrapThreadPool& pool_;$/;"	m	class:BootstrapWorker
pop	KmerHashTable.h	/^  size_t size_, pop;$/;"	m	struct:KmerHashTable
pos	KmerIndex.h	/^    int pos;$/;"	m	struct:VariantParameterEntry
pos	KmerIndex.h	/^  int pos; $/;"	m	struct:ContigToTranscript
pos	MinCollector.h	/^  int pos;$/;"	m	struct:BiasWeightStruct
post_bias_	EMAlgorithm.h	/^  std::vector<double> post_bias_;$/;"	m	struct:EMAlgorithm
pretty_num	common.cpp	/^std::string pretty_num(int num) {$/;"	f
pretty_num	common.cpp	/^std::string pretty_num(int64_t num) {$/;"	f
pretty_num	common.cpp	/^std::string pretty_num(size_t num) {$/;"	f
primed_	H5Writer.h	/^    bool primed_;$/;"	m	class:H5Writer
printHisto	Inspect.h	/^void printHisto(const unordered_map<int,int>& m, const string& header) {$/;"	f
printTranscripts	Fusion.hpp	/^void printTranscripts(const KmerIndex& index, std::stringstream& o, const std::string s,$/;"	f
printVC	EMAlgorithm.h	/^  void printVC(int vc) {$/;"	f	struct:EMAlgorithm
printVector	Inspect.h	/^void printVector(const vector<int>& v) {$/;"	f
printVector	ProcessReads.cpp	/^void printVector(const std::vector<int>& v, std::ostream& o) {$/;"	f
processAln	ProcessReads.cpp	/^void MasterProcessor::processAln(const EMAlgorithm& em, bool useEM = true) {$/;"	f	class:MasterProcessor
processBuffer	ProcessReads.cpp	/^void BUSProcessor::processBuffer() {$/;"	f	class:BUSProcessor
processBuffer	ProcessReads.cpp	/^void ReadProcessor::processBuffer() {$/;"	f	class:ReadProcessor
processBufferGenome	ProcessReads.cpp	/^void AlnProcessor::processBufferGenome() {$/;"	f	class:AlnProcessor
processBufferTrans	ProcessReads.cpp	/^void AlnProcessor::processBufferTrans() {$/;"	f	class:AlnProcessor
processReads	ProcessReads.cpp	/^void MasterProcessor::processReads() {$/;"	f	class:MasterProcessor
pseudo_quant	common.h	/^  bool pseudo_quant;$/;"	m	struct:ProgramOptions
pseudobam	common.h	/^  bool pseudobam;$/;"	m	struct:ProgramOptions
pseudobatch	ProcessReads.h	/^  PseudoAlignmentBatch pseudobatch;$/;"	m	class:AlnProcessor
pseudobatch	ProcessReads.h	/^  PseudoAlignmentBatch pseudobatch;$/;"	m	class:BUSProcessor
pseudobatch	ProcessReads.h	/^  PseudoAlignmentBatch pseudobatch;$/;"	m	class:ReadProcessor
pseudobatch_stragglers	ProcessReads.h	/^  std::vector<PseudoAlignmentBatch> pseudobatch_stragglers;$/;"	m	class:MasterProcessor
pseudobatchf_in	ProcessReads.h	/^  std::ifstream pseudobatchf_in;$/;"	m	class:MasterProcessor
pseudobatchf_out	ProcessReads.h	/^  std::ofstream pseudobatchf_out;$/;"	m	class:MasterProcessor
quals	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> quals;$/;"	m	class:AlnProcessor
quals	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> quals;$/;"	m	class:BUSProcessor
quals	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> quals;$/;"	m	class:ReadProcessor
r1empty	PseudoBam.h	/^  bool r1empty; \/\/ 2$/;"	m	struct:PseudoAlignmentInfo
r2empty	PseudoBam.h	/^  bool r2empty; \/\/ 4$/;"	m	struct:PseudoAlignmentInfo
raise	KmerIterator.cpp	/^void KmerIterator::raise(Kmer& km, Kmer& rep) {$/;"	f	class:KmerIterator
readPseudoAlignmentBatch	PseudoBam.cpp	/^void readPseudoAlignmentBatch(std::ifstream& in, PseudoAlignmentBatch& batch) {$/;"	f
read_dataset	h5utils.h	/^void read_dataset(hid_t group_id,$/;"	f
read_vector	h5utils.cpp	/^void read_vector($/;"	f
readbatch_id	ProcessReads.h	/^  int readbatch_id = -1;$/;"	m	class:SequenceReader
reader_lock	ProcessReads.h	/^  std::mutex reader_lock;$/;"	m	class:MasterProcessor
rec	ProcessReads.h	/^  bam1_t *rec;$/;"	m	class:BamSequenceReader
ref	KmerIndex.h	/^    std::string ref;$/;"	m	struct:VariantParameterEntry
ref	MinCollector.cpp	/^enum RefInfo { ref, alt, alt2, nonvariant };$/;"	e	enum:RefInfo	file:
refOrAlt	MinCollector.cpp	/^RefInfo refOrAlt(std::string t) {$/;"	f
referrer	MinCollector.h	/^  int referrer;$/;"	m	struct:BiasWeightStruct
rep	Kmer.cpp	/^Kmer Kmer::rep() const {$/;"	f	class:Kmer
reserve	KmerHashTable.h	/^  void reserve(size_t sz, bool expand = true) {$/;"	f	struct:KmerHashTable
reserveNfiles	ProcessReads.cpp	/^void BamSequenceReader::reserveNfiles(int n) {$/;"	f	class:BamSequenceReader
reserveNfiles	ProcessReads.cpp	/^void FastqSequenceReader::reserveNfiles(int n) {$/;"	f	class:FastqSequenceReader
reset	ProcessReads.cpp	/^void BamSequenceReader::reset() {$/;"	f	class:BamSequenceReader
reset	ProcessReads.cpp	/^void FastqSequenceReader::reset() {$/;"	f	class:FastqSequenceReader
reset	ProcessReads.cpp	/^void SequenceReader::reset() {$/;"	f	class:SequenceReader
revcomp	KmerIndex.cpp	/^std::string revcomp(const std::string s) {$/;"	f
reverseComplementSeqInData	ProcessReads.cpp	/^void reverseComplementSeqInData(bam1_t &b) {$/;"	f
reverseIndexTransform	EMAlgorithm.h	/^  std::vector<int> reverseIndexTransform; \/\/ theta index to transcript index$/;"	m	struct:EMAlgorithm
revseq	PseudoBam.cpp	/^void revseq(char *b1, char *b2, const char *s, const char *q, int n) {$/;"	f
rho_	EMAlgorithm.h	/^  std::vector<double> rho_;$/;"	m	struct:EMAlgorithm
rho_set_	EMAlgorithm.h	/^  bool rho_set_;$/;"	m	struct:EMAlgorithm
rndup	KmerHashTable.h	/^  size_t rndup(size_t v) {$/;"	f	struct:KmerHashTable
root_	H5Writer.h	/^    hid_t root_;$/;"	m	class:H5Converter
root_	H5Writer.h	/^    hid_t root_;$/;"	m	class:H5Writer
rtrim	KmerIndex.cpp	/^static inline void rtrim(std::string &s) {$/;"	f	file:
run	EMAlgorithm.h	/^  void run(size_t n_iter = 10000, size_t min_rounds=50, bool verbose = true, bool recomputeEffLen = true) {$/;"	f	struct:EMAlgorithm
run_em	Bootstrap.cpp	/^EMAlgorithm Bootstrap::run_em() {$/;"	f	class:Bootstrap
rw_from_counts	H5Writer.cpp	/^void H5Converter::rw_from_counts(hid_t group_id, const std::string& count_name, const std::string& out_fname) {$/;"	f	class:H5Converter
s	kseq.h	/^	char *s;$/;"	m	struct:__kstring_t
s_	KmerIterator.hpp	/^  const char *s_;$/;"	m	class:KmerIterator
sample	Multinomial.hpp	/^        std::vector<int> sample() {$/;"	f	class:Multinomial
sample	Multinomial.hpp	/^        std::vector<int> sample(int nsamp) {$/;"	f	class:Multinomial
sample_name	common.h	/^  std::string sample_name;$/;"	m	struct:ProgramOptions
sd	common.h	/^  double sd;$/;"	m	struct:ProgramOptions
searchFusion	Fusion.hpp	/^void searchFusion(const KmerIndex &index, const ProgramOptions& opt,$/;"	f
seed	common.h	/^  size_t seed;$/;"	m	struct:ProgramOptions
seed_	Bootstrap.h	/^  size_t seed_;$/;"	m	class:Bootstrap
seeds_	Bootstrap.h	/^    std::vector<size_t> seeds_;$/;"	m	class:BootstrapThreadPool
seeds_mutex_	Bootstrap.h	/^    std::mutex seeds_mutex_;$/;"	m	class:BootstrapThreadPool
sense	KmerIndex.h	/^  bool sense; \/\/ true for sense, $/;"	m	struct:ContigToTranscript
sense	KmerIndex.h	/^  bool sense; \/\/ true for sense, false for anti-sense$/;"	m	struct:TRInfo
seq	KmerIndex.h	/^  std::string seq; \/\/ sequence$/;"	m	struct:Contig
seq	ProcessReads.h	/^  std::vector<kseq_t*> seq;$/;"	m	class:FastqSequenceReader
seq	common.h	/^  std::vector<BUSOptionSubstr> seq;$/;"	m	struct:BUSOptions
seq_enc	ProcessReads.cpp	/^const std::string BamSequenceReader::seq_enc = "=ACMGRSVTWYHKDBN";$/;"	m	class:BamSequenceReader	file:
seq_enc	ProcessReads.h	/^  static const std::string seq_enc;$/;"	m	class:BamSequenceReader
seqs	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> seqs;$/;"	m	class:AlnProcessor
seqs	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> seqs;$/;"	m	class:BUSProcessor
seqs	ProcessReads.h	/^  std::vector<std::pair<const char*, int>> seqs;$/;"	m	class:ReadProcessor
setDir	KmerIndex.h	/^  inline void setDir(bool _isFw) {_pos = (_pos & 0x0FFFFFFF) | ((_isFw) ? 0 : 0xF0000000);}$/;"	f	struct:KmerEntry
setPos	KmerIndex.h	/^  inline void setPos(int p) {_pos = (_pos & 0xF0000000) | (p & 0x0FFFFFFF);}$/;"	f	struct:KmerEntry
set_deleted	Kmer.cpp	/^void Kmer::set_deleted() {$/;"	f	class:Kmer
set_empty	Kmer.cpp	/^void Kmer::set_empty() {$/;"	f	class:Kmer
set_k	Kmer.cpp	/^void Kmer::set_k(unsigned int _k) {$/;"	f	class:Kmer
set_kmer	Kmer.cpp	/^void Kmer::set_kmer(const char *s)  {$/;"	f	class:Kmer
set_start	EMAlgorithm.h	/^  void set_start(const EMAlgorithm& em_start) {$/;"	f	struct:EMAlgorithm
shadeToColorTranscriptMap	KmerIndex.h	/^  std::unordered_map<int, int> shadeToColorTranscriptMap;$/;"	m	struct:KmerIndex
simpleIntersect	Fusion.hpp	/^std::vector<int> simpleIntersect(const KmerIndex& index, const std::vector<std::pair<KmerEntry,int>>& v) {$/;"	f
single_end	common.h	/^  bool single_end;$/;"	m	struct:ProgramOptions
single_overhang	common.h	/^  bool single_overhang;$/;"	m	struct:ProgramOptions
size	KmerHashTable.h	/^  size_t size() const {$/;"	f	struct:KmerHashTable
size_	KmerHashTable.h	/^  size_t size_, pop;$/;"	m	struct:KmerHashTable
skip	KmerIndex.h	/^  int skip;$/;"	m	struct:KmerIndex
skip	common.h	/^  int skip;$/;"	m	struct:ProgramOptions
smooth	common.h	/^  bool smooth;$/;"	m	struct:ProgramOptions
split_complex_multimap_	EMAlgorithm.h	/^  std::vector<std::vector<double>> split_complex_multimap_;$/;"	m	struct:EMAlgorithm
start	GeneModel.h	/^  int start,stop; \/\/ start 0-based, 1 bp past end for stop$/;"	m	struct:GeneModel
start	GeneModel.h	/^  int start,stop;$/;"	m	struct:ExonModel
start	GeneModel.h	/^  int start,stop;$/;"	m	struct:TranscriptModel
start	Inspect.h	/^  int start;$/;"	m	struct:ECStruct
start	KmerIndex.h	/^  int start;$/;"	m	struct:TRInfo
start	common.h	/^  int start;$/;"	m	struct:BUSOptionSubstr
start_lens	Inspect.h	/^  std::vector<std::pair<int,int>> start_lens;$/;"	m	struct:ECStruct
start_time_	H5Writer.h	/^    std::string start_time_;$/;"	m	class:H5Converter
state	ProcessReads.h	/^  bool state; \/\/ is the file open$/;"	m	class:SequenceReader
std	GeneModel.h	/^namespace std {$/;"	n
stop	GeneModel.h	/^  int start,stop; \/\/ start 0-based, 1 bp past end for stop$/;"	m	struct:GeneModel
stop	GeneModel.h	/^  int start,stop;$/;"	m	struct:ExonModel
stop	GeneModel.h	/^  int start,stop;$/;"	m	struct:TranscriptModel
stop	Inspect.h	/^  int stop;$/;"	m	struct:ECStruct
stop	KmerIndex.h	/^  int stop; \/\/exclusive [start,stop)$/;"	m	struct:TRInfo
stop	common.h	/^  int stop;$/;"	m	struct:BUSOptionSubstr
strand	GeneModel.h	/^  bool strand;$/;"	m	struct:ExonModel
strand	GeneModel.h	/^  bool strand;$/;"	m	struct:GeneModel
strand	GeneModel.h	/^  bool strand;$/;"	m	struct:TranscriptAlignment
strand	GeneModel.h	/^  bool strand;$/;"	m	struct:TranscriptModel
strand	common.h	/^  StrandType strand;$/;"	m	struct:ProgramOptions
strandToChar	GeneModel.cpp	/^char strandToChar(bool s) {$/;"	f
strand_specific	common.h	/^  bool strand_specific;$/;"	m	struct:ProgramOptions
stringToBinary	BUSData.cpp	/^uint64_t stringToBinary(const char* s, const size_t len, uint32_t &flag) {$/;"	f
stringToBinary	BUSData.cpp	/^uint64_t stringToBinary(const std::string &s, uint32_t &flag) {$/;"	f
table	KmerHashTable.h	/^  value_type *table;$/;"	m	struct:KmerHashTable
targ_ids_	H5Writer.h	/^    std::vector<std::string> targ_ids_;$/;"	m	class:H5Converter
target_left_lens_	KmerIndex.h	/^  std::vector<int> target_left_lens_;$/;"	m	struct:KmerIndex
target_lens_	KmerIndex.h	/^  std::vector<int> target_lens_;$/;"	m	struct:KmerIndex
target_names_	EMAlgorithm.h	/^  const std::vector<std::string>& target_names_;$/;"	m	struct:EMAlgorithm
target_names_	KmerIndex.h	/^  std::vector<std::string> target_names_;$/;"	m	struct:KmerIndex
target_right_lens_	KmerIndex.h	/^  std::vector<int> target_right_lens_;$/;"	m	struct:KmerIndex
target_seqs_	KmerIndex.h	/^  std::vector<std::string> target_seqs_; \/\/ populated on demand$/;"	m	struct:KmerIndex
target_seqs_loaded	KmerIndex.h	/^  bool target_seqs_loaded;$/;"	m	struct:KmerIndex
tc	ProcessReads.h	/^  MinCollector& tc;$/;"	m	class:MasterProcessor
tc	ProcessReads.h	/^  const MinCollector& tc;$/;"	m	class:BUSProcessor
tc	ProcessReads.h	/^  const MinCollector& tc;$/;"	m	class:ReadProcessor
tc_	Bootstrap.h	/^    const MinCollector& tc_;$/;"	m	class:BootstrapThreadPool
tc_	Bootstrap.h	/^  const MinCollector& tc_;$/;"	m	class:Bootstrap
tc_	EMAlgorithm.h	/^  const MinCollector& tc_;$/;"	m	struct:EMAlgorithm
technology	common.h	/^  std::string technology;$/;"	m	struct:ProgramOptions
text	BUSData.h	/^  std::string text;$/;"	m	struct:BUSHeader
thetas	EMAlgorithm.h	/^  std::vector<double> thetas;$/;"	m	struct:EMAlgorithm
thread_id_	Bootstrap.h	/^    size_t thread_id_;$/;"	m	class:BootstrapWorker
threads	common.h	/^  int threads;$/;"	m	struct:ProgramOptions
threads_	Bootstrap.h	/^    std::vector<std::thread> threads_;$/;"	m	class:BootstrapThreadPool
tlencount	ProcessReads.h	/^  std::atomic<int> tlencount;$/;"	m	class:MasterProcessor
tlencounts	ProcessReads.h	/^  std::vector<int> tlencounts;$/;"	m	class:MasterProcessor
tlist	Inspect.h	/^  std::vector<int> tlist;$/;"	m	struct:ECStruct
tmp_bc	ProcessReads.h	/^  std::vector<std::vector<int32_t>> tmp_bc;$/;"	m	class:MasterProcessor
toString	Kmer.cpp	/^std::string Kmer::toString() const {$/;"	f	class:Kmer
toString	Kmer.cpp	/^void Kmer::toString(char *s) const {$/;"	f	class:Kmer
toString	KmerIndex.h	/^    std::string toString() const {$/;"	f	struct:VariantParameterEntry
to_json	PlaintextWriter.cpp	/^std::string to_json(const std::string& id, const std::string& val, bool quote,$/;"	f
tpm_buf_	H5Writer.h	/^    std::vector<double> tpm_buf_;$/;"	m	class:H5Converter
tpms	EMAlgorithm.h	/^  std::vector<double> tpms;$/;"	m	struct:EMAlgorithm
trNameToId	GeneModel.h	/^  std::unordered_map<std::string, int> trNameToId;$/;"	m	struct:Transcriptome
transcriptLength	BUSData.h	/^  uint32_t transcriptLength;$/;"	m	struct:BUSTranscript
transcriptToEParam_	EMAlgorithm.h	/^  std::vector<std::vector<int>> transcriptToEParam_;$/;"	m	struct:EMAlgorithm
transcriptToParam	KmerIndex.h	/^  std::unordered_map<int, std::unordered_map<int, int>> transcriptToParam;$/;"	m	struct:KmerIndex
transcripts	BUSData.h	/^  std::vector<BUSTranscript> transcripts;$/;"	m	struct:BUSHeader
transcripts	GeneModel.h	/^  std::vector<TranscriptModel> transcripts;$/;"	m	struct:Transcriptome
transcripts	GeneModel.h	/^  std::vector<int> transcripts;  $/;"	m	struct:GeneModel
transcripts	KmerIndex.h	/^  std::vector<ContigToTranscript> transcripts;$/;"	m	struct:Contig
transfasta	common.h	/^  std::vector<std::string> transfasta;$/;"	m	struct:ProgramOptions
translateTrPosition	GeneModel.cpp	/^bool Transcriptome::translateTrPosition(const int tr, const int pos, const int rlen, bool strand, TranscriptAlignment &aln) const {$/;"	f	class:Transcriptome
trid	KmerIndex.h	/^    int trid;$/;"	m	struct:VariantParameterEntry
trid	KmerIndex.h	/^  int trid;$/;"	m	struct:ContigToTranscript
trid	KmerIndex.h	/^  int trid;$/;"	m	struct:TRInfo
trid	MinCollector.h	/^  int trid;$/;"	m	struct:BiasWeightStruct
trim	KmerIndex.cpp	/^static inline void trim(std::string &s) {$/;"	f	file:
true_counts_	Bootstrap.h	/^    const std::vector<int> true_counts_;$/;"	m	class:BootstrapThreadPool
trunc_gaussian_counts	weights.cpp	/^std::vector<int> trunc_gaussian_counts(int start, int stop, double mean,$/;"	f
trunc_gaussian_fld	weights.cpp	/^std::vector<double> trunc_gaussian_fld(int start, int stop, double mean,$/;"	f
twin	Kmer.cpp	/^Kmer Kmer::twin() const {$/;"	f	class:Kmer
twin_table	Kmer.cpp	/^static const uint64_t twin_table[256] = {$/;"	v	file:
u	PseudoBam.h	/^  std::vector<int32_t> u;$/;"	m	struct:PseudoAlignmentInfo
uint	common.h	/^typedef unsigned int uint;$/;"	t
uint	h5utils.h	/^typedef unsigned int uint;$/;"	t
umi	ProcessReads.h	/^  char *umi;$/;"	m	class:BamSequenceReader
umi	common.h	/^  BUSOptionSubstr umi;$/;"	m	struct:BUSOptions
umi	common.h	/^  bool umi;$/;"	m	struct:ProgramOptions
umi_files	ProcessReads.h	/^  std::vector<std::string> umi_files;$/;"	m	class:FastqSequenceReader
umi_files	common.h	/^  std::vector<std::string> umi_files;$/;"	m	struct:ProgramOptions
umi_len	ProcessReads.h	/^  int umi_len[33];$/;"	m	class:BUSProcessor
umilen	BUSData.h	/^  uint32_t umilen;$/;"	m	struct:BUSHeader
umis	ProcessReads.h	/^  std::vector<std::string> umis;$/;"	m	class:AlnProcessor
umis	ProcessReads.h	/^  std::vector<std::string> umis;$/;"	m	class:ReadProcessor
unionShades	MinCollector.cpp	/^void MinCollector::unionShades($/;"	f	class:MinCollector
unique	KmerIndex.cpp	/^std::vector<int> unique(const std::vector<int>& u) {$/;"	f
update	ProcessReads.cpp	/^void MasterProcessor::update(const std::vector<int>& c, const std::vector<std::vector<int> > &newEcs, const std::vector<variant_class>& newVEcs, const std::unordered_map<int, double>& newBiasMap, const std::unordered_map<int, int>& aseCounts,$/;"	f	class:MasterProcessor
update_eff_lens	weights.cpp	/^std::vector<double> update_eff_lens($/;"	f
update_hexamer	weights.cpp	/^inline int update_hexamer(int hex, char c, bool revcomp) {$/;"	f
usage	main.cpp	/^void usage() {$/;"	f
usageBus	main.cpp	/^void usageBus() {$/;"	f
usageEM	main.cpp	/^void usageEM(bool valid_input = true) {$/;"	f
usageEMOnly	main.cpp	/^void usageEMOnly() {$/;"	f
usageIndex	main.cpp	/^void usageIndex() {$/;"	f
usageInspect	main.cpp	/^void usageInspect() {$/;"	f
usageMerge	main.cpp	/^void usageMerge(bool valid_input = true) {$/;"	f
usagePseudo	main.cpp	/^void usagePseudo(bool valid_input = true) {$/;"	f
usageh5dump	main.cpp	/^void usageh5dump() {$/;"	f
useEM	ProcessReads.h	/^  bool useEM;$/;"	m	class:AlnProcessor
variant_class	MinCollector.h	/^typedef std::pair<std::vector<int>, std::vector<int>> variant_class;$/;"	t
variant_info	MinCollector.h	/^typedef std::tuple<std::vector<int>, std::vector<int>, std::vector<int>> variant_info;$/;"	t
vc_counts_	EMAlgorithm.h	/^  std::vector<int> vc_counts_;$/;"	m	struct:EMAlgorithm
vc_trids_	EMAlgorithm.h	/^  std::vector<std::vector<int>> vc_trids_;$/;"	m	struct:EMAlgorithm
vc_trids_unique_	EMAlgorithm.h	/^  std::vector<std::vector<int>> vc_trids_unique_;$/;"	m	struct:EMAlgorithm
vcf_file	common.h	/^  std::string vcf_file;$/;"	m	struct:ProgramOptions
vcmap	KmerIndex.h	/^  std::vector<std::pair<std::vector<int>, std::vector<int>>> vcmap;$/;"	m	struct:KmerIndex
vcmapinv	KmerIndex.h	/^  std::unordered_map<std::pair<std::vector<int>, std::vector<int>>, int, SortedVectorPairHasher> vcmapinv;$/;"	m	struct:KmerIndex
vec_to_ptr	h5utils.cpp	/^char* vec_to_ptr(const std::vector<std::string>& v) {$/;"	f
vec_to_ptr	h5utils.cpp	/^const double* vec_to_ptr(const std::vector<double>& v) {$/;"	f
vec_to_ptr	h5utils.cpp	/^const int* vec_to_ptr(const std::vector<int>& v) {$/;"	f
vector_to_h5	h5utils.h	/^herr_t vector_to_h5($/;"	f
verbose	common.h	/^  bool verbose;$/;"	m	struct:ProgramOptions
version	BUSData.h	/^  uint32_t version;$/;"	m	struct:BUSHeader
w_e_fast_	EMAlgorithm.h	/^  std::vector<std::vector<double>> w_e_fast_;$/;"	m	struct:EMAlgorithm
w_v_fast_	EMAlgorithm.h	/^  std::vector<std::vector<double>> w_v_fast_;$/;"	m	struct:EMAlgorithm
w_v_lambda_fast_	EMAlgorithm.h	/^  std::vector<std::vector<int>> w_v_lambda_fast_;$/;"	m	struct:EMAlgorithm
w_v_unique_	EMAlgorithm.h	/^  std::vector<std::vector<double>> w_v_unique_;$/;"	m	struct:EMAlgorithm
weight	MinCollector.h	/^  double weight;$/;"	m	struct:BiasWeightStruct
weight_map_	EMAlgorithm.h	/^  WeightMap weight_map_;$/;"	m	struct:EMAlgorithm
write	EMAlgorithm.h	/^  void write(const std::string& out_fname) const {$/;"	f	struct:EMAlgorithm
write	KmerIndex.cpp	/^void KmerIndex::write(const std::string& index_out, bool writeKmerTable) {$/;"	f	class:KmerIndex
write	MinCollector.cpp	/^void MinCollector::write(const std::string& pseudoprefix) const {$/;"	f	class:MinCollector
write	MinCollector.h	/^  void write(std::ostream& o) {$/;"	f	struct:MinCollector
writeBUSData	BUSTools.cpp	/^void writeBUSData(std::ofstream &out, const std::vector<BUSData> &bv) {$/;"	f
writeBUSHeader	BUSTools.cpp	/^void writeBUSHeader(std::ofstream &out, int bclen, int umilen) {$/;"	f
writeBatchMatrix	PlaintextWriter.cpp	/^void writeBatchMatrix($/;"	f
writeCellIds	PlaintextWriter.cpp	/^void writeCellIds($/;"	f
writeECList	PlaintextWriter.cpp	/^void writeECList($/;"	f
writeFLD	PlaintextWriter.cpp	/^void writeFLD(const std::string &filename, const std::vector<std::pair<double, double>> &flds) {$/;"	f
writeGeneList	PlaintextWriter.cpp	/^void writeGeneList(const std::string &filename, const Transcriptome& model) {$/;"	f
writePseudoAlignmentBatch	PseudoBam.cpp	/^void writePseudoAlignmentBatch(std::ofstream& of, const PseudoAlignmentBatch& batch) {$/;"	f
writePseudoBam	ProcessReads.cpp	/^void MasterProcessor::writePseudoBam(const std::vector<bam1_t> &bv) {$/;"	f	class:MasterProcessor
writePseudoBamHeader	KmerIndex.cpp	/^void KmerIndex::writePseudoBamHeader(std::ostream &o) const {$/;"	f	class:KmerIndex
writeSortedPseudobam	ProcessReads.cpp	/^void MasterProcessor::writeSortedPseudobam(const std::vector<std::vector<bam1_t>> &bvv) { $/;"	f	class:MasterProcessor
writeSparseBatchMatrix	PlaintextWriter.h	/^void writeSparseBatchMatrix($/;"	f
write_aux	H5Writer.cpp	/^void H5Converter::write_aux() {$/;"	f	class:H5Converter
write_bootstrap	H5Writer.cpp	/^void H5Writer::write_bootstrap(const EMAlgorithm& em, int bs_id) {$/;"	f	class:H5Writer
write_index	common.h	/^  bool write_index;$/;"	m	struct:ProgramOptions
write_lock_	Bootstrap.h	/^    std::mutex write_lock_;$/;"	m	class:BootstrapThreadPool
write_main	H5Writer.cpp	/^void H5Writer::write_main(const EMAlgorithm& em,$/;"	f	class:H5Writer
writer_	Bootstrap.h	/^    BootstrapWriter *writer_;$/;"	m	class:BootstrapThreadPool
writer_lock	ProcessReads.h	/^  std::mutex writer_lock;$/;"	m	class:MasterProcessor
~AlnProcessor	ProcessReads.cpp	/^AlnProcessor::~AlnProcessor() {$/;"	f	class:AlnProcessor
~BUSProcessor	ProcessReads.cpp	/^BUSProcessor::~BUSProcessor() {$/;"	f	class:BUSProcessor
~BamSequenceReader	ProcessReads.cpp	/^BamSequenceReader::~BamSequenceReader() {$/;"	f	class:BamSequenceReader
~BootstrapThreadPool	Bootstrap.cpp	/^BootstrapThreadPool::~BootstrapThreadPool() {$/;"	f	class:BootstrapThreadPool
~BootstrapWriter	Bootstrap.h	/^    virtual ~BootstrapWriter() {};$/;"	f	class:BootstrapWriter
~EMAlgorithm	EMAlgorithm.h	/^  ~EMAlgorithm() {}$/;"	f	struct:EMAlgorithm
~FastqSequenceReader	ProcessReads.cpp	/^FastqSequenceReader::~FastqSequenceReader() {$/;"	f	class:FastqSequenceReader
~H5Converter	H5Writer.cpp	/^H5Converter::~H5Converter() {$/;"	f	class:H5Converter
~H5Writer	H5Writer.cpp	/^H5Writer::~H5Writer() {$/;"	f	class:H5Writer
~KmerHashTable	KmerHashTable.h	/^  ~KmerHashTable() {$/;"	f	struct:KmerHashTable
~KmerIndex	KmerIndex.h	/^  ~KmerIndex() {}$/;"	f	struct:KmerIndex
~MasterProcessor	ProcessReads.h	/^  ~MasterProcessor() {$/;"	f	class:MasterProcessor
~ReadProcessor	ProcessReads.cpp	/^ReadProcessor::~ReadProcessor() {$/;"	f	class:ReadProcessor
~SequenceReader	ProcessReads.h	/^  virtual ~SequenceReader() {}$/;"	f	class:SequenceReader
